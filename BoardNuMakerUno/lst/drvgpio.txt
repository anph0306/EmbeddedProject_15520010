; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\drvgpio.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\drvgpio.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Template -I..\NUC140BSP\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\NUC140BSP\NuvotonPlatform_Keil\Include -I..\NUC140BSP\NuvotonPlatform_Keil\Include\Driver -I..\NUC140BSP\CMSIS\CM0\CoreSupport -I..\NUC140BSP\NuvotonPlatform_Keil\Include\NUC1xx-LB_002 -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__UVISION_VERSION=517 --omf_browse=.\obj\drvgpio.crf ..\NUC140BSP\NuvotonPlatform_Keil\Src\Driver\DrvGPIO.c]
                          THUMB

                          AREA ||i.DrvGPIO_Close||, CODE, READONLY, ALIGN=2

                  DrvGPIO_Close PROC
;;;162    /*---------------------------------------------------------------------------------------------------------*/
;;;163    int32_t DrvGPIO_Close(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  b508              PUSH     {r3,lr}
;;;164    {
;;;165        volatile uint32_t u32Reg;
;;;166    
;;;167        if ((i32Bit < 0) || (i32Bit > 16))
000002  2911              CMP      r1,#0x11
000004  d301              BCC      |L1.10|
;;;168        {
;;;169            return E_DRVGPIO_ARGUMENT;
000006  480a              LDR      r0,|L1.48|
;;;170        }
;;;171        
;;;172        u32Reg = (uint32_t)&GPIOA->PMD + (port*PORT_OFFSET);    
;;;173        outpw(u32Reg, inpw(u32Reg) | (0x3<<(i32Bit*2)));
;;;174    	
;;;175    	GPIO_DBNCECON->DBNCECON.ICLK_ON = 0; 
;;;176    
;;;177        return E_SUCCESS;
;;;178    }	
000008  bd08              POP      {r3,pc}
                  |L1.10|
00000a  4a0a              LDR      r2,|L1.52|
00000c  0180              LSLS     r0,r0,#6              ;172
00000e  1880              ADDS     r0,r0,r2              ;172
000010  9000              STR      r0,[sp,#0]            ;173
000012  6800              LDR      r0,[r0,#0]            ;173
000014  004a              LSLS     r2,r1,#1              ;173
000016  2103              MOVS     r1,#3                 ;173
000018  4091              LSLS     r1,r1,r2              ;173
00001a  4308              ORRS     r0,r0,r1              ;173
00001c  9900              LDR      r1,[sp,#0]            ;173
00001e  6008              STR      r0,[r1,#0]            ;173
000020  4805              LDR      r0,|L1.56|
000022  6801              LDR      r1,[r0,#0]            ;175
000024  2220              MOVS     r2,#0x20              ;175
000026  4391              BICS     r1,r1,r2              ;175
000028  6001              STR      r1,[r0,#0]            ;175
00002a  2000              MOVS     r0,#0                 ;177
00002c  bd08              POP      {r3,pc}
;;;179    
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0xffff8901
                  |L1.52|
                          DCD      0x50004000
                  |L1.56|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_ClrBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_ClrBit PROC
;;;251    /*---------------------------------------------------------------------------------------------------------*/
;;;252    int32_t DrvGPIO_ClrBit(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  2911              CMP      r1,#0x11
;;;253    {
000002  d301              BCC      |L2.8|
;;;254    	GPIO_T * tGPIO;
;;;255    
;;;256        if ((i32Bit < 0) || (i32Bit > 16))
;;;257        {
;;;258            return E_DRVGPIO_ARGUMENT;
000004  4805              LDR      r0,|L2.28|
;;;259        }
;;;260    
;;;261    	tGPIO = (GPIO_T *)((uint32_t)GPIOA + (port*PORT_OFFSET));  
;;;262    
;;;263    	tGPIO->DOUT &= ~(1 << i32Bit);
;;;264    
;;;265    	return E_SUCCESS;    
;;;266    }
000006  4770              BX       lr
                  |L2.8|
000008  4a05              LDR      r2,|L2.32|
00000a  0180              LSLS     r0,r0,#6              ;261
00000c  1880              ADDS     r0,r0,r2              ;261
00000e  6882              LDR      r2,[r0,#8]            ;263
000010  2301              MOVS     r3,#1                 ;263
000012  408b              LSLS     r3,r3,r1              ;263
000014  439a              BICS     r2,r2,r3              ;263
000016  6082              STR      r2,[r0,#8]            ;263
000018  2000              MOVS     r0,#0                 ;265
00001a  4770              BX       lr
;;;267    
                          ENDP

                  |L2.28|
                          DCD      0xffff8901
                  |L2.32|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_ClrBitMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_ClrBitMask PROC
;;;427    /*---------------------------------------------------------------------------------------------------------*/
;;;428    int32_t DrvGPIO_ClrBitMask(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  4a06              LDR      r2,|L3.28|
;;;429    {
000002  b508              PUSH     {r3,lr}
;;;430        volatile uint32_t u32Reg;
;;;431    
;;;432        u32Reg = (uint32_t)&GPIOA->DMASK + (port*PORT_OFFSET);    
000004  0180              LSLS     r0,r0,#6
000006  1880              ADDS     r0,r0,r2
;;;433    
;;;434    	outpw(u32Reg, inpw(u32Reg) & ~(1<<i32Bit));
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  408a              LSLS     r2,r2,r1
000010  9900              LDR      r1,[sp,#0]
000012  4390              BICS     r0,r0,r2
000014  6008              STR      r0,[r1,#0]
;;;435    	
;;;436    	return E_SUCCESS;
000016  2000              MOVS     r0,#0
;;;437    }
000018  bd08              POP      {r3,pc}
;;;438    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x5000400c

                          AREA ||i.DrvGPIO_ClrPortMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_ClrPortMask PROC
;;;492    /*---------------------------------------------------------------------------------------------------------*/
;;;493    int32_t DrvGPIO_ClrPortMask(E_DRVGPIO_PORT port, int32_t i32MaskData)
000000  0182              LSLS     r2,r0,#6
000002  4803              LDR      r0,|L4.16|
000004  1810              ADDS     r0,r2,r0
000006  68c2              LDR      r2,[r0,#0xc]
;;;494    {
;;;495    	outpw((uint32_t)&GPIOA->DMASK + (port*PORT_OFFSET), DrvGPIO_GetPortMask(port) & ~(i32MaskData));
000008  438a              BICS     r2,r2,r1
00000a  60c2              STR      r2,[r0,#0xc]
;;;496    	
;;;497    	return E_SUCCESS;
00000c  2000              MOVS     r0,#0
;;;498    }
00000e  4770              BX       lr
;;;499    
                          ENDP

                  |L4.16|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_DisableDebounce||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableDebounce PROC
;;;581    /*---------------------------------------------------------------------------------------------------------*/
;;;582    int32_t DrvGPIO_DisableDebounce(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  4a08              LDR      r2,|L5.36|
;;;583    {
000002  b508              PUSH     {r3,lr}
;;;584        volatile uint32_t u32Reg;
;;;585    
;;;586        u32Reg = (uint32_t)&GPIOA->DBEN + (port*PORT_OFFSET);
000004  0180              LSLS     r0,r0,#6
000006  1880              ADDS     r0,r0,r2
;;;587            
;;;588        outpw(u32Reg, inpw(u32Reg) & ~(1<<i32Bit));
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  408a              LSLS     r2,r2,r1
000010  9900              LDR      r1,[sp,#0]
000012  4390              BICS     r0,r0,r2
000014  6008              STR      r0,[r1,#0]
;;;589        
;;;590        GPIO_DBNCECON->DBNCECON.ICLK_ON = 0;
000016  4804              LDR      r0,|L5.40|
000018  6801              LDR      r1,[r0,#0]
00001a  2220              MOVS     r2,#0x20
00001c  4391              BICS     r1,r1,r2
00001e  6001              STR      r1,[r0,#0]
;;;591    
;;;592    	return E_SUCCESS;
000020  2000              MOVS     r0,#0
;;;593    }
000022  bd08              POP      {r3,pc}
;;;594    
                          ENDP

                  |L5.36|
                          DCD      0x50004014
                  |L5.40|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_DisableDigitalInputBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableDigitalInputBit PROC
;;;533    /*---------------------------------------------------------------------------------------------------------*/
;;;534    int32_t DrvGPIO_DisableDigitalInputBit(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  4a06              LDR      r2,|L6.28|
;;;535    {
000002  b508              PUSH     {r3,lr}
;;;536        volatile uint32_t u32Reg = (uint32_t)&GPIOA->OFFD + (port*PORT_OFFSET);
000004  0180              LSLS     r0,r0,#6
000006  1880              ADDS     r0,r0,r2
;;;537    
;;;538        outpw(u32Reg, inpw(u32Reg) | (1 << (i32Bit+16)));
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  3110              ADDS     r1,r1,#0x10
000010  408a              LSLS     r2,r2,r1
000012  9900              LDR      r1,[sp,#0]
000014  4310              ORRS     r0,r0,r2
000016  6008              STR      r0,[r1,#0]
;;;539    
;;;540        return E_SUCCESS;
000018  2000              MOVS     r0,#0
;;;541    }
00001a  bd08              POP      {r3,pc}
;;;542    
                          ENDP

                  |L6.28|
                          DCD      0x50004004

                          AREA ||i.DrvGPIO_DisableEINT0||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableEINT0 PROC
;;;842    /*---------------------------------------------------------------------------------------------------------*/
;;;843    void DrvGPIO_DisableEINT0(void)
000000  b508              PUSH     {r3,lr}
;;;844    {
;;;845        volatile uint32_t u32Reg;
;;;846    
;;;847        u32Reg = (uint32_t)&GPIOA->IEN + (E_GPB*PORT_OFFSET);
000002  4805              LDR      r0,|L7.24|
;;;848    
;;;849        outpw(u32Reg, inpw(u32Reg) & ~((1UL<<(14))|(1UL<<(14+16))));	 
000004  9000              STR      r0,[sp,#0]
000006  6801              LDR      r1,[r0,#0]
000008  4a04              LDR      r2,|L7.28|
00000a  4011              ANDS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;850    
;;;851        NVIC_DisableIRQ(EINT0_IRQn);
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       NVIC_DisableIRQ
;;;852    }
000014  bd08              POP      {r3,pc}
;;;853    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x5000405c
                  |L7.28|
                          DCD      0xbfffbfff

                          AREA ||i.DrvGPIO_DisableEINT1||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableEINT1 PROC
;;;921    /*---------------------------------------------------------------------------------------------------------*/
;;;922    void DrvGPIO_DisableEINT1(void)
000000  b508              PUSH     {r3,lr}
;;;923    {
;;;924        volatile uint32_t u32Reg;
;;;925    
;;;926        u32Reg = (uint32_t)&GPIOA->IEN + (E_GPB*PORT_OFFSET);
000002  4805              LDR      r0,|L8.24|
;;;927    
;;;928        outpw(u32Reg, inpw(u32Reg) & ~((1UL<<(15))|(1UL<<(15+16))));	 
000004  9000              STR      r0,[sp,#0]
000006  6801              LDR      r1,[r0,#0]
000008  4a04              LDR      r2,|L8.28|
00000a  4011              ANDS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;929    
;;;930        NVIC_DisableIRQ(EINT1_IRQn);
00000e  2003              MOVS     r0,#3
000010  f7fffffe          BL       NVIC_DisableIRQ
;;;931    }
000014  bd08              POP      {r3,pc}
;;;932    
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      0x5000405c
                  |L8.28|
                          DCD      0x7fff7fff

                          AREA ||i.DrvGPIO_DisableInt||, CODE, READONLY, ALIGN=2

                  DrvGPIO_DisableInt PROC
;;;734    /*---------------------------------------------------------------------------------------------------------*/
;;;735    int32_t DrvGPIO_DisableInt(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  b538              PUSH     {r3-r5,lr}
;;;736    {                                             
000002  4604              MOV      r4,r0
;;;737        volatile uint32_t u32Reg;
;;;738    
;;;739        /* Disable both rising/falling or both high level/low level interrupts */
;;;740        u32Reg = (uint32_t)&GPIOA->IEN + (port*PORT_OFFSET);
000004  4a10              LDR      r2,|L9.72|
000006  0180              LSLS     r0,r0,#6
000008  1880              ADDS     r0,r0,r2
;;;741    
;;;742        outpw(u32Reg, inpw(u32Reg) & ~((1<<i32Bit) | (1<<(i32Bit+16))));	 
00000a  9000              STR      r0,[sp,#0]
00000c  2001              MOVS     r0,#1
00000e  4602              MOV      r2,r0
000010  408a              LSLS     r2,r2,r1
000012  3110              ADDS     r1,r1,#0x10
000014  4088              LSLS     r0,r0,r1
000016  4302              ORRS     r2,r2,r0
000018  9800              LDR      r0,[sp,#0]
00001a  6800              LDR      r0,[r0,#0]
00001c  9900              LDR      r1,[sp,#0]
00001e  4390              BICS     r0,r0,r2
000020  6008              STR      r0,[r1,#0]
;;;743    
;;;744        /* Disable the relative interrupt of M0 */
;;;745        if ((port == E_GPA) || (port == E_GPB))
000022  2c00              CMP      r4,#0
000024  d001              BEQ      |L9.42|
000026  2c01              CMP      r4,#1
000028  d102              BNE      |L9.48|
                  |L9.42|
;;;746        {
;;;747            NVIC_DisableIRQ(GPAB_IRQn);
00002a  2004              MOVS     r0,#4
00002c  f7fffffe          BL       NVIC_DisableIRQ
                  |L9.48|
;;;748        }
;;;749    
;;;750        if ((port == E_GPC) || (port == E_GPD) || (port == E_GPE))
000030  2c02              CMP      r4,#2
000032  d003              BEQ      |L9.60|
000034  2c03              CMP      r4,#3
000036  d001              BEQ      |L9.60|
000038  2c04              CMP      r4,#4
00003a  d102              BNE      |L9.66|
                  |L9.60|
;;;751        {
;;;752            NVIC_DisableIRQ(GPCDE_IRQn);
00003c  2005              MOVS     r0,#5
00003e  f7fffffe          BL       NVIC_DisableIRQ
                  |L9.66|
;;;753        }  
;;;754          
;;;755        return E_SUCCESS;
000042  2000              MOVS     r0,#0
;;;756    }
000044  bd38              POP      {r3-r5,pc}
;;;757    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      0x5000401c

                          AREA ||i.DrvGPIO_EnableDebounce||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableDebounce PROC
;;;555    /*---------------------------------------------------------------------------------------------------------*/
;;;556    int32_t DrvGPIO_EnableDebounce(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  4a08              LDR      r2,|L10.36|
;;;557    {
000002  b508              PUSH     {r3,lr}
;;;558        volatile uint32_t u32Reg;
;;;559    
;;;560        u32Reg = (uint32_t)&GPIOA->DBEN + (port*PORT_OFFSET);    
000004  0180              LSLS     r0,r0,#6
000006  1880              ADDS     r0,r0,r2
;;;561    
;;;562        outpw(u32Reg, inpw(u32Reg) | (1<<i32Bit));
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  408a              LSLS     r2,r2,r1
000010  9900              LDR      r1,[sp,#0]
000012  4310              ORRS     r0,r0,r2
000014  6008              STR      r0,[r1,#0]
;;;563    
;;;564    	GPIO_DBNCECON->DBNCECON.ICLK_ON = 1;
000016  4804              LDR      r0,|L10.40|
000018  6801              LDR      r1,[r0,#0]
00001a  2220              MOVS     r2,#0x20
00001c  4311              ORRS     r1,r1,r2
00001e  6001              STR      r1,[r0,#0]
;;;565    
;;;566        return E_SUCCESS;
000020  2000              MOVS     r0,#0
;;;567    }
000022  bd08              POP      {r3,pc}
;;;568    
                          ENDP

                  |L10.36|
                          DCD      0x50004014
                  |L10.40|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_EnableDigitalInputBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableDigitalInputBit PROC
;;;512    /*---------------------------------------------------------------------------------------------------------*/
;;;513    int32_t DrvGPIO_EnableDigitalInputBit(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  4a06              LDR      r2,|L11.28|
;;;514    {
000002  b508              PUSH     {r3,lr}
;;;515        volatile uint32_t u32Reg = (uint32_t)&GPIOA->OFFD + (port*PORT_OFFSET);
000004  0180              LSLS     r0,r0,#6
000006  1880              ADDS     r0,r0,r2
;;;516    
;;;517        outpw(u32Reg, inpw(u32Reg) & ~(1 << (i32Bit+16)));
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  3110              ADDS     r1,r1,#0x10
000010  408a              LSLS     r2,r2,r1
000012  9900              LDR      r1,[sp,#0]
000014  4390              BICS     r0,r0,r2
000016  6008              STR      r0,[r1,#0]
;;;518    
;;;519        return E_SUCCESS;
000018  2000              MOVS     r0,#0
;;;520    }
00001a  bd08              POP      {r3,pc}
;;;521    /*---------------------------------------------------------------------------------------------------------*/
                          ENDP

                  |L11.28|
                          DCD      0x50004004

                          AREA ||i.DrvGPIO_EnableEINT0||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableEINT0 PROC
;;;798    /*---------------------------------------------------------------------------------------------------------*/
;;;799    void DrvGPIO_EnableEINT0(E_DRVGPIO_INT_TYPE TriggerType, E_DRVGPIO_INT_MODE Mode, GPIO_EINT0_CALLBACK pfEINT0Callback)
000000  b538              PUSH     {r3-r5,lr}
;;;800    {
;;;801        volatile uint32_t u32Reg;
;;;802    
;;;803        if ((TriggerType == E_IO_BOTH_EDGE) && (Mode == E_MODE_LEVEL))
000002  2802              CMP      r0,#2
000004  d101              BNE      |L12.10|
000006  2901              CMP      r1,#1
000008  d031              BEQ      |L12.110|
                  |L12.10|
;;;804            return ;
;;;805    
;;;806        u32Reg = (uint32_t)&GPIOA->IEN + (E_GPB*PORT_OFFSET);
00000a  4b19              LDR      r3,|L12.112|
;;;807    	if (TriggerType == E_IO_RISING)
;;;808        {
;;;809            outpw(u32Reg, inpw(u32Reg) | (1UL<<(14+16)));	 
;;;810    	}
;;;811        else if (TriggerType == E_IO_FALLING)
;;;812    	{
;;;813            outpw(u32Reg, inpw(u32Reg) | (1UL<<(14)));	 
00000c  9300              STR      r3,[sp,#0]
00000e  2301              MOVS     r3,#1
000010  039b              LSLS     r3,r3,#14
000012  2800              CMP      r0,#0                 ;807
000014  d004              BEQ      |L12.32|
000016  2801              CMP      r0,#1                 ;811
000018  d007              BEQ      |L12.42|
;;;814    	}
;;;815        else if (TriggerType == E_IO_BOTH_EDGE)
00001a  2802              CMP      r0,#2
00001c  d009              BEQ      |L12.50|
00001e  e00e              B        |L12.62|
                  |L12.32|
000020  9800              LDR      r0,[sp,#0]            ;809
000022  6800              LDR      r0,[r0,#0]            ;809
000024  2401              MOVS     r4,#1                 ;809
000026  07a4              LSLS     r4,r4,#30             ;809
000028  e006              B        |L12.56|
                  |L12.42|
00002a  9800              LDR      r0,[sp,#0]            ;813
00002c  6800              LDR      r0,[r0,#0]            ;813
00002e  4318              ORRS     r0,r0,r3              ;813
000030  e003              B        |L12.58|
                  |L12.50|
;;;816        {  
;;;817            outpw(u32Reg, inpw(u32Reg) | (1UL<<(14))|(1UL<<(14+16)));	 
000032  9800              LDR      r0,[sp,#0]
000034  6800              LDR      r0,[r0,#0]
000036  4c0f              LDR      r4,|L12.116|
                  |L12.56|
000038  4320              ORRS     r0,r0,r4              ;809
                  |L12.58|
00003a  9c00              LDR      r4,[sp,#0]
00003c  6020              STR      r0,[r4,#0]
                  |L12.62|
;;;818    	}    	 
;;;819    
;;;820         /* Configure to be level trigger or edge trigger */
;;;821        u32Reg = (uint32_t)&GPIOA->IMD + (E_GPB*PORT_OFFSET);
00003e  480c              LDR      r0,|L12.112|
000040  1f00              SUBS     r0,r0,#4
;;;822    	if (Mode == E_MODE_EDGE)
000042  9000              STR      r0,[sp,#0]
000044  2900              CMP      r1,#0
000046  d002              BEQ      |L12.78|
;;;823    		outpw(u32Reg, inpw(u32Reg) & ~(1<<14));
;;;824    	else if(Mode == E_MODE_LEVEL)
000048  2901              CMP      r1,#1
00004a  d003              BEQ      |L12.84|
00004c  e006              B        |L12.92|
                  |L12.78|
00004e  6800              LDR      r0,[r0,#0]            ;823
000050  4398              BICS     r0,r0,r3              ;823
000052  e001              B        |L12.88|
                  |L12.84|
;;;825    		outpw(u32Reg, inpw(u32Reg) | (1<<14));
000054  6800              LDR      r0,[r0,#0]
000056  4318              ORRS     r0,r0,r3
                  |L12.88|
000058  9900              LDR      r1,[sp,#0]
00005a  6008              STR      r0,[r1,#0]
                  |L12.92|
;;;826    
;;;827       _pfEINT0Callback = pfEINT0Callback;
00005c  4806              LDR      r0,|L12.120|
;;;828    
;;;829        NVIC_SetPriority(EINT0_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
00005e  2102              MOVS     r1,#2
000060  6082              STR      r2,[r0,#8]  ; _pfEINT0Callback
000062  4608              MOV      r0,r1
000064  f7fffffe          BL       NVIC_SetPriority
;;;830        NVIC_EnableIRQ(EINT0_IRQn);
000068  2002              MOVS     r0,#2
00006a  f7fffffe          BL       NVIC_EnableIRQ
                  |L12.110|
;;;831    }
00006e  bd38              POP      {r3-r5,pc}
;;;832    
                          ENDP

                  |L12.112|
                          DCD      0x5000405c
                  |L12.116|
                          DCD      0x40004000
                  |L12.120|
                          DCD      ||.data||

                          AREA ||i.DrvGPIO_EnableEINT1||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableEINT1 PROC
;;;877    /*---------------------------------------------------------------------------------------------------------*/
;;;878    void DrvGPIO_EnableEINT1(E_DRVGPIO_INT_TYPE TriggerType, E_DRVGPIO_INT_MODE Mode, GPIO_EINT1_CALLBACK pfEINT1Callback)
000000  b538              PUSH     {r3-r5,lr}
;;;879    {
;;;880        volatile uint32_t u32Reg;
;;;881    
;;;882        if ((TriggerType == E_IO_BOTH_EDGE) && (Mode == E_MODE_LEVEL))
000002  2802              CMP      r0,#2
000004  d101              BNE      |L13.10|
000006  2901              CMP      r1,#1
000008  d031              BEQ      |L13.110|
                  |L13.10|
;;;883            return ;
;;;884    
;;;885        u32Reg = (uint32_t)&GPIOA->IEN + (E_GPB*PORT_OFFSET);
00000a  4b19              LDR      r3,|L13.112|
;;;886    	if (TriggerType == E_IO_RISING)
;;;887        {
;;;888            outpw(u32Reg, inpw(u32Reg) | (1UL<<(15+16)));	 
;;;889    	}
;;;890        else if (TriggerType == E_IO_FALLING)
;;;891    	{
;;;892            outpw(u32Reg, inpw(u32Reg) | (1UL<<(15)));	 
00000c  9300              STR      r3,[sp,#0]
00000e  2301              MOVS     r3,#1
000010  03db              LSLS     r3,r3,#15
000012  2800              CMP      r0,#0                 ;886
000014  d004              BEQ      |L13.32|
000016  2801              CMP      r0,#1                 ;890
000018  d007              BEQ      |L13.42|
;;;893    	}
;;;894        else if (TriggerType == E_IO_BOTH_EDGE)
00001a  2802              CMP      r0,#2
00001c  d009              BEQ      |L13.50|
00001e  e00e              B        |L13.62|
                  |L13.32|
000020  9800              LDR      r0,[sp,#0]            ;888
000022  6800              LDR      r0,[r0,#0]            ;888
000024  2401              MOVS     r4,#1                 ;888
000026  07e4              LSLS     r4,r4,#31             ;888
000028  e006              B        |L13.56|
                  |L13.42|
00002a  9800              LDR      r0,[sp,#0]            ;892
00002c  6800              LDR      r0,[r0,#0]            ;892
00002e  4318              ORRS     r0,r0,r3              ;892
000030  e003              B        |L13.58|
                  |L13.50|
;;;895        {  
;;;896            outpw(u32Reg, inpw(u32Reg) | (1UL<<(15))|(1UL<<(15+16)));	 
000032  9800              LDR      r0,[sp,#0]
000034  6800              LDR      r0,[r0,#0]
000036  4c0f              LDR      r4,|L13.116|
                  |L13.56|
000038  4320              ORRS     r0,r0,r4              ;888
                  |L13.58|
00003a  9c00              LDR      r4,[sp,#0]
00003c  6020              STR      r0,[r4,#0]
                  |L13.62|
;;;897    	}    	 
;;;898    
;;;899         /* Configure to be level trigger or edge trigger */
;;;900        u32Reg = (uint32_t)&GPIOA->IMD + (E_GPB*PORT_OFFSET);
00003e  480c              LDR      r0,|L13.112|
000040  1f00              SUBS     r0,r0,#4
;;;901    	if (Mode == E_MODE_EDGE)
000042  9000              STR      r0,[sp,#0]
000044  2900              CMP      r1,#0
000046  d002              BEQ      |L13.78|
;;;902    		outpw(u32Reg, inpw(u32Reg) & ~(1<<15));
;;;903    	else if(Mode == E_MODE_LEVEL)
000048  2901              CMP      r1,#1
00004a  d003              BEQ      |L13.84|
00004c  e006              B        |L13.92|
                  |L13.78|
00004e  6800              LDR      r0,[r0,#0]            ;902
000050  4398              BICS     r0,r0,r3              ;902
000052  e001              B        |L13.88|
                  |L13.84|
;;;904    		outpw(u32Reg, inpw(u32Reg) | (1<<15));
000054  6800              LDR      r0,[r0,#0]
000056  4318              ORRS     r0,r0,r3
                  |L13.88|
000058  9900              LDR      r1,[sp,#0]
00005a  6008              STR      r0,[r1,#0]
                  |L13.92|
;;;905    
;;;906        _pfEINT1Callback = pfEINT1Callback;
00005c  4806              LDR      r0,|L13.120|
;;;907    
;;;908        NVIC_SetPriority(EINT1_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
00005e  2102              MOVS     r1,#2
000060  60c2              STR      r2,[r0,#0xc]  ; _pfEINT1Callback
000062  2003              MOVS     r0,#3
000064  f7fffffe          BL       NVIC_SetPriority
;;;909        NVIC_EnableIRQ(EINT1_IRQn);
000068  2003              MOVS     r0,#3
00006a  f7fffffe          BL       NVIC_EnableIRQ
                  |L13.110|
;;;910    }
00006e  bd38              POP      {r3-r5,pc}
;;;911    
                          ENDP

                  |L13.112|
                          DCD      0x5000405c
                  |L13.116|
                          DCD      0x80008000
                  |L13.120|
                          DCD      ||.data||

                          AREA ||i.DrvGPIO_EnableInt||, CODE, READONLY, ALIGN=2

                  DrvGPIO_EnableInt PROC
;;;671    /*---------------------------------------------------------------------------------------------------------*/
;;;672    int32_t DrvGPIO_EnableInt(E_DRVGPIO_PORT port, int32_t i32Bit, E_DRVGPIO_INT_TYPE TriggerType, E_DRVGPIO_INT_MODE Mode)
000000  b5f8              PUSH     {r3-r7,lr}
;;;673    {
000002  4604              MOV      r4,r0
;;;674        volatile uint32_t u32Reg;
;;;675    
;;;676        if ((TriggerType == E_IO_BOTH_EDGE) && (Mode == E_MODE_LEVEL))
;;;677            return E_DRVGPIO_ARGUMENT;
000004  482a              LDR      r0,|L14.176|
000006  2a02              CMP      r2,#2                 ;676
000008  d101              BNE      |L14.14|
00000a  2b01              CMP      r3,#1                 ;676
00000c  d04e              BEQ      |L14.172|
                  |L14.14|
;;;678    
;;;679        if ((port == E_GPB) && ((i32Bit == 14) || (i32Bit == 15)))
00000e  2c01              CMP      r4,#1
000010  d103              BNE      |L14.26|
000012  290e              CMP      r1,#0xe
000014  d04a              BEQ      |L14.172|
000016  290f              CMP      r1,#0xf
000018  d048              BEQ      |L14.172|
                  |L14.26|
;;;680        {
;;;681            /* GPB14 is EINT0, GPB15 is EINT1. Both of them can't be assigned to GPAB interrupt */
;;;682            return E_DRVGPIO_ARGUMENT;    
;;;683        }
;;;684        
;;;685        /* Configure the interrupt to be rising/falling when edge trigger or high/low level when level trigger */
;;;686        u32Reg = (uint32_t)&GPIOA->IEN + (port*PORT_OFFSET);
00001a  01a5              LSLS     r5,r4,#6
00001c  4e25              LDR      r6,|L14.180|
00001e  46ac              MOV      r12,r5
000020  19ad              ADDS     r5,r5,r6
;;;687    	if (TriggerType == E_IO_RISING)
;;;688    		outpw(u32Reg, inpw(u32Reg) | (1<<(i32Bit+16)));	 
000022  9500              STR      r5,[sp,#0]
000024  460d              MOV      r5,r1
000026  2601              MOVS     r6,#1                 ;673
000028  3510              ADDS     r5,r5,#0x10
00002a  4637              MOV      r7,r6                 ;673
00002c  40af              LSLS     r7,r7,r5
;;;689    	else if(TriggerType == E_IO_FALLING)
;;;690    		outpw(u32Reg, inpw(u32Reg) | (1<<i32Bit));	 
00002e  408e              LSLS     r6,r6,r1
000030  2a00              CMP      r2,#0                 ;687
000032  d01b              BEQ      |L14.108|
000034  2a01              CMP      r2,#1                 ;689
000036  d01d              BEQ      |L14.116|
;;;691    	else if(TriggerType == E_IO_BOTH_EDGE)  
000038  2a02              CMP      r2,#2
00003a  d137              BNE      |L14.172|
;;;692    		outpw(u32Reg, inpw(u32Reg) | (1<<i32Bit)| (1<<(i32Bit+16)));	 
00003c  9a00              LDR      r2,[sp,#0]
00003e  4631              MOV      r1,r6                 ;691
000040  6812              LDR      r2,[r2,#0]
000042  4339              ORRS     r1,r1,r7
000044  4311              ORRS     r1,r1,r2
                  |L14.70|
000046  9a00              LDR      r2,[sp,#0]
000048  6011              STR      r1,[r2,#0]
;;;693    	else
;;;694    		return E_DRVGPIO_ARGUMENT;
;;;695    
;;;696        /* Configure to be level trigger or edge trigger */
;;;697        u32Reg = (uint32_t)&GPIOA->IMD + (port*PORT_OFFSET);
00004a  4a1a              LDR      r2,|L14.180|
00004c  4661              MOV      r1,r12                ;692
00004e  1f12              SUBS     r2,r2,#4
000050  1889              ADDS     r1,r1,r2
;;;698    	if(Mode == E_MODE_EDGE)
000052  9100              STR      r1,[sp,#0]
000054  2b00              CMP      r3,#0
000056  d011              BEQ      |L14.124|
;;;699    		outpw(u32Reg, inpw(u32Reg) & ~(1<<i32Bit));
;;;700    	else if(Mode ==E_MODE_LEVEL)
000058  2b01              CMP      r3,#1
00005a  d127              BNE      |L14.172|
;;;701    		outpw(u32Reg, inpw(u32Reg) | (1<<i32Bit));
00005c  6808              LDR      r0,[r1,#0]
00005e  4330              ORRS     r0,r0,r6
                  |L14.96|
000060  6008              STR      r0,[r1,#0]
;;;702    	else
;;;703    		return E_DRVGPIO_ARGUMENT;
;;;704        
;;;705        /* Enable the relative interrupt of M0 */
;;;706        if ((port == E_GPA) || (port == E_GPB))
000062  2c00              CMP      r4,#0
000064  d00d              BEQ      |L14.130|
000066  2c01              CMP      r4,#1
000068  d00b              BEQ      |L14.130|
00006a  e011              B        |L14.144|
                  |L14.108|
00006c  9900              LDR      r1,[sp,#0]            ;688
00006e  6809              LDR      r1,[r1,#0]            ;688
000070  4339              ORRS     r1,r1,r7              ;688
000072  e7e8              B        |L14.70|
                  |L14.116|
000074  9900              LDR      r1,[sp,#0]            ;690
000076  6809              LDR      r1,[r1,#0]            ;690
000078  4331              ORRS     r1,r1,r6              ;690
00007a  e7e4              B        |L14.70|
                  |L14.124|
00007c  6808              LDR      r0,[r1,#0]            ;699
00007e  43b0              BICS     r0,r0,r6              ;699
000080  e7ee              B        |L14.96|
                  |L14.130|
;;;707        {
;;;708            NVIC_SetPriority(GPAB_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
000082  2102              MOVS     r1,#2
000084  2004              MOVS     r0,#4
000086  f7fffffe          BL       NVIC_SetPriority
;;;709            NVIC_EnableIRQ(GPAB_IRQn);
00008a  2004              MOVS     r0,#4
00008c  f7fffffe          BL       NVIC_EnableIRQ
                  |L14.144|
;;;710        }
;;;711    
;;;712        if ((port == E_GPC) || (port == E_GPD) || (port == E_GPE))
000090  2c02              CMP      r4,#2
000092  d003              BEQ      |L14.156|
000094  2c03              CMP      r4,#3
000096  d001              BEQ      |L14.156|
000098  2c04              CMP      r4,#4
00009a  d106              BNE      |L14.170|
                  |L14.156|
;;;713        {
;;;714            NVIC_SetPriority(GPCDE_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
00009c  2102              MOVS     r1,#2
00009e  2005              MOVS     r0,#5
0000a0  f7fffffe          BL       NVIC_SetPriority
;;;715            NVIC_EnableIRQ(GPCDE_IRQn);
0000a4  2005              MOVS     r0,#5
0000a6  f7fffffe          BL       NVIC_EnableIRQ
                  |L14.170|
;;;716        }    
;;;717    
;;;718        return E_SUCCESS;
0000aa  2000              MOVS     r0,#0
                  |L14.172|
;;;719    }
0000ac  bdf8              POP      {r3-r7,pc}
;;;720    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L14.176|
                          DCD      0xffff8901
                  |L14.180|
                          DCD      0x5000401c

                          AREA ||i.DrvGPIO_GetBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetBit PROC
;;;223    /*---------------------------------------------------------------------------------------------------------*/
;;;224    int32_t DrvGPIO_GetBit(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  b508              PUSH     {r3,lr}
;;;225    {
;;;226        volatile uint32_t u32Reg;
;;;227            
;;;228        if ((i32Bit < 0) || (i32Bit > 16))
000002  2911              CMP      r1,#0x11
000004  d301              BCC      |L15.10|
;;;229        {
;;;230            return E_DRVGPIO_ARGUMENT;
000006  4805              LDR      r0,|L15.28|
;;;231        }
;;;232    
;;;233        u32Reg = (uint32_t)&GPIOA->PIN + (port*PORT_OFFSET);    
;;;234    
;;;235        return ((inpw(u32Reg)>>i32Bit) & 0x1);
;;;236    }
000008  bd08              POP      {r3,pc}
                  |L15.10|
00000a  4a05              LDR      r2,|L15.32|
00000c  0180              LSLS     r0,r0,#6              ;233
00000e  1880              ADDS     r0,r0,r2              ;233
000010  9000              STR      r0,[sp,#0]            ;235
000012  6800              LDR      r0,[r0,#0]            ;235
000014  40c8              LSRS     r0,r0,r1              ;235
000016  07c0              LSLS     r0,r0,#31             ;235
000018  0fc0              LSRS     r0,r0,#31             ;235
00001a  bd08              POP      {r3,pc}
;;;237    
                          ENDP

                  |L15.28|
                          DCD      0xffff8901
                  |L15.32|
                          DCD      0x50004010

                          AREA ||i.DrvGPIO_GetBitMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetBitMask PROC
;;;404    /*---------------------------------------------------------------------------------------------------------*/
;;;405    int32_t DrvGPIO_GetBitMask(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  4a04              LDR      r2,|L16.20|
;;;406    {
000002  b508              PUSH     {r3,lr}
;;;407        volatile uint32_t u32Reg;
;;;408    
;;;409        u32Reg = (uint32_t)&GPIOA->DMASK + (port*PORT_OFFSET);    
000004  0180              LSLS     r0,r0,#6
000006  1880              ADDS     r0,r0,r2
;;;410    
;;;411        return ((inpw(u32Reg)>>i32Bit) & 0x1);
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  40c8              LSRS     r0,r0,r1
00000e  07c0              LSLS     r0,r0,#31
000010  0fc0              LSRS     r0,r0,#31
;;;412    }
000012  bd08              POP      {r3,pc}
;;;413    
                          ENDP

                  |L16.20|
                          DCD      0x5000400c

                          AREA ||i.DrvGPIO_GetDebounceSampleCycle||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetDebounceSampleCycle PROC
;;;637    /*---------------------------------------------------------------------------------------------------------*/
;;;638    int32_t DrvGPIO_GetDebounceSampleCycle(void)
000000  4802              LDR      r0,|L17.12|
;;;639    {   
;;;640        return GPIO_DBNCECON->DBNCECON.DBCLKSEL;
000002  6800              LDR      r0,[r0,#0]
000004  0700              LSLS     r0,r0,#28
000006  0f00              LSRS     r0,r0,#28
;;;641    }
000008  4770              BX       lr
;;;642    
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_GetDoutBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetDoutBit PROC
;;;329    /*---------------------------------------------------------------------------------------------------------*/
;;;330    int32_t DrvGPIO_GetDoutBit(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  290f              CMP      r1,#0xf
;;;331    {    
000002  d301              BCC      |L18.8|
;;;332        if ((i32Bit < 0) || (i32Bit >= 15))
;;;333        {
;;;334            return E_DRVGPIO_ARGUMENT;
000004  4804              LDR      r0,|L18.24|
;;;335        }
;;;336     
;;;337        return ((inpw((uint32_t)&GPIOA->DOUT + (port*PORT_OFFSET))>>i32Bit) & 0x1);
;;;338    }
000006  4770              BX       lr
                  |L18.8|
000008  4a04              LDR      r2,|L18.28|
00000a  0180              LSLS     r0,r0,#6              ;337
00000c  1880              ADDS     r0,r0,r2              ;337
00000e  6880              LDR      r0,[r0,#8]            ;337
000010  40c8              LSRS     r0,r0,r1              ;337
000012  07c0              LSLS     r0,r0,#31             ;337
000014  0fc0              LSRS     r0,r0,#31             ;337
000016  4770              BX       lr
;;;339    
                          ENDP

                  |L18.24|
                          DCD      0xffff8901
                  |L18.28|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetIntStatus||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetIntStatus PROC
;;;945    /*---------------------------------------------------------------------------------------------------------*/
;;;946    int32_t DrvGPIO_GetIntStatus(E_DRVGPIO_PORT port)
000000  4902              LDR      r1,|L19.12|
;;;947    {
;;;948    	GPIO_T * tGPIO;
;;;949    
;;;950    	tGPIO = (GPIO_T *)((uint32_t)GPIOA + (port*PORT_OFFSET));  
000002  0180              LSLS     r0,r0,#6
000004  1840              ADDS     r0,r0,r1
;;;951    
;;;952    	return tGPIO->ISRC;
000006  6a00              LDR      r0,[r0,#0x20]
;;;953    }
000008  4770              BX       lr
;;;954    
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetPortBits||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetPortBits PROC
;;;304    /*---------------------------------------------------------------------------------------------------------*/
;;;305    int32_t DrvGPIO_GetPortBits(E_DRVGPIO_PORT port)
000000  4902              LDR      r1,|L20.12|
;;;306    {
;;;307    	GPIO_T * tGPIO;
;;;308    
;;;309    	tGPIO = (GPIO_T *)((uint32_t)GPIOA + (port*PORT_OFFSET));  
000002  0180              LSLS     r0,r0,#6
000004  1840              ADDS     r0,r0,r1
;;;310    
;;;311        return tGPIO->PIN;
000006  6900              LDR      r0,[r0,#0x10]
;;;312    }
000008  4770              BX       lr
;;;313    
                          ENDP

00000a  0000              DCW      0x0000
                  |L20.12|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetPortDoutBits||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetPortDoutBits PROC
;;;353    /*---------------------------------------------------------------------------------------------------------*/
;;;354    int32_t DrvGPIO_GetPortDoutBits(E_DRVGPIO_PORT port)
000000  2804              CMP      r0,#4
;;;355    {
000002  d901              BLS      |L21.8|
;;;356        if (port > 4)
;;;357        {
;;;358            return E_DRVGPIO_ARGUMENT;
000004  4803              LDR      r0,|L21.20|
;;;359        }
;;;360    
;;;361        return inpw((uint32_t)&GPIOA->DOUT + (port*PORT_OFFSET));
;;;362    }
000006  4770              BX       lr
                  |L21.8|
000008  4903              LDR      r1,|L21.24|
00000a  0180              LSLS     r0,r0,#6              ;361
00000c  1840              ADDS     r0,r0,r1              ;361
00000e  6880              LDR      r0,[r0,#8]            ;361
000010  4770              BX       lr
;;;363    
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      0xffff8901
                  |L21.24|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetPortMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetPortMask PROC
;;;473    /*---------------------------------------------------------------------------------------------------------*/
;;;474    int32_t DrvGPIO_GetPortMask(E_DRVGPIO_PORT port)
000000  4902              LDR      r1,|L22.12|
;;;475    {
;;;476    	return inpw((uint32_t)&GPIOA->DMASK + (port* PORT_OFFSET)); 
000002  0180              LSLS     r0,r0,#6
000004  1840              ADDS     r0,r0,r1
000006  68c0              LDR      r0,[r0,#0xc]
;;;477    }
000008  4770              BX       lr
;;;478    
                          ENDP

00000a  0000              DCW      0x0000
                  |L22.12|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_GetVersion||, CODE, READONLY, ALIGN=2

                  DrvGPIO_GetVersion PROC
;;;1466   /*---------------------------------------------------------------------------------------------------------*/
;;;1467   int32_t DrvGPIO_GetVersion(void)
000000  4800              LDR      r0,|L23.4|
;;;1468   {
;;;1469      return DRVGPIO_VERSION_NUM;
;;;1470   }
000002  4770              BX       lr
;;;1471   
                          ENDP

                  |L23.4|
                          DCD      0x00010405

                          AREA ||i.DrvGPIO_InitFunction||, CODE, READONLY, ALIGN=2

                  DrvGPIO_InitFunction PROC
;;;1048   /*---------------------------------------------------------------------------------------------------------*/
;;;1049   int32_t DrvGPIO_InitFunction(E_DRVGPIO_FUNC function)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1050   {  
000002  2401              MOVS     r4,#1
;;;1051       uint8_t u8Offset;
;;;1052   
;;;1053       switch ( function )
;;;1054   	{
;;;1055   		/*---------------------------------------------------------------------------------------------------------*/
;;;1056   		/* GPIO                                                                                                    */
;;;1057   		/*---------------------------------------------------------------------------------------------------------*/
;;;1058   		case E_FUNC_GPIO:
;;;1059   		{
;;;1060   		  outpw(&SYS->GPAMFP, 0);
;;;1061   			outpw(&SYS->GPBMFP, 0);
;;;1062   			outpw(&SYS->GPCMFP, 0);
;;;1063   			outpw(&SYS->GPDMFP, 0);
;;;1064   			outpw(&SYS->GPEMFP, 0);		  	
;;;1065   		}break;
;;;1066   
;;;1067   		/*---------------------------------------------------------------------------------------------------------*/
;;;1068   		/* Clock frequence output                                                                                        */
;;;1069   		/*---------------------------------------------------------------------------------------------------------*/
;;;1070   		case E_FUNC_CLKO:
;;;1071   		{
;;;1072   		  	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<12));
;;;1073   		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<10));
;;;1074   		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1075   		}break;
;;;1076   
;;;1077   		/*---------------------------------------------------------------------------------------------------------*/
;;;1078   		/* I2C0                                                                                                    */
;;;1079   		/*---------------------------------------------------------------------------------------------------------*/
;;;1080   		case E_FUNC_I2C0:
;;;1081   		{
;;;1082   		  	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x3<<8));
;;;1083   		}break;		
;;;1084   
;;;1085   		/*---------------------------------------------------------------------------------------------------------*/
;;;1086   		/* I2C1                                                                                                    */
;;;1087   		/*---------------------------------------------------------------------------------------------------------*/
;;;1088   		case E_FUNC_I2C1:
;;;1089   		{
;;;1090   		  	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x3<<10));
;;;1091   		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1092   		}break;
;;;1093   
;;;1094   		/*---------------------------------------------------------------------------------------------------------*/
;;;1095   		/* I2S                                                                                                     */
;;;1096   		/*---------------------------------------------------------------------------------------------------------*/
;;;1097   		case E_FUNC_I2S:	
;;;1098   		{
;;;1099             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0xF<<0));
;;;1100             	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x1<<15));
;;;1101             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1F<<5));			
;;;1102   		}break;
;;;1103   		
;;;1104   		/*---------------------------------------------------------------------------------------------------------*/
;;;1105   		/* CAN0                                                                                                    */
;;;1106   		/*---------------------------------------------------------------------------------------------------------*/
;;;1107   		case E_FUNC_CAN0:	
;;;1108   		{
;;;1109             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0x3<<6));
;;;1110   		}break;	
;;;1111   
;;;1112   		/*---------------------------------------------------------------------------------------------------------*/
;;;1113   		/* Analog Comparator                                                                                       */
;;;1114   		/*---------------------------------------------------------------------------------------------------------*/
;;;1115   		case E_FUNC_ACMP0:	
;;;1116   		case E_FUNC_ACMP1:
;;;1117   		{
;;;1118               if (function == E_FUNC_ACMP0)
;;;1119                   u8Offset = 6;
;;;1120               else
;;;1121                   u8Offset = 14;
;;;1122             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0x3<<u8Offset));
;;;1123   		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1124   		}break;
;;;1125   
;;;1126   		/*---------------------------------------------------------------------------------------------------------*/
;;;1127   		/* SPI                                                                                                     */
;;;1128   		/*---------------------------------------------------------------------------------------------------------*/
;;;1129   		case E_FUNC_SPI0:	
;;;1130   		{
;;;1131             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0xF<<0));
;;;1132             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0xF<<5));
;;;1133   
;;;1134   		}break;
;;;1135   
;;;1136   		case E_FUNC_SPI0_SS1:	
;;;1137   		{
;;;1138             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<10));
;;;1139             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<0));
;;;1140   		}break;
;;;1141   
;;;1142   		case E_FUNC_SPI0_2BIT_MODE:	
;;;1143   		{
;;;1144             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0x3<<4));
;;;1145   		}break;
;;;1146   
;;;1147   		case E_FUNC_SPI1:
;;;1148   		{
;;;1149             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0xF<<8));
;;;1150   		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1151   		}break;
;;;1152   
;;;1153   		case E_FUNC_SPI1_SS1:	
;;;1154   		{
;;;1155             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<9));
;;;1156             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<1));
;;;1157   		}break;
;;;1158   
;;;1159   		case E_FUNC_SPI1_2BIT_MODE:	
;;;1160   		{
;;;1161             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0x3<<12));
;;;1162   		}break;
;;;1163   
;;;1164   		case E_FUNC_SPI2:	
;;;1165   		{
;;;1166             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0xF<<0));
;;;1167   		}break;				
;;;1168   
;;;1169   		case E_FUNC_SPI2_SS1:	
;;;1170   		{
;;;1171              	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x1<<7));
;;;1172               outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<2));
;;;1173   		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1174   		}break;
;;;1175   
;;;1176   		case E_FUNC_SPI2_2BIT_MODE:	
;;;1177   		{
;;;1178             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0x3<<4));
;;;1179   		}break;
;;;1180   
;;;1181   		case E_FUNC_SPI3:	
;;;1182   		{
;;;1183             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0xF<<8));
;;;1184    		}break;
;;;1185   
;;;1186   		case E_FUNC_SPI3_SS1:	
;;;1187   		{
;;;1188             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<14));
;;;1189               outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<3));
;;;1190   		}break;
;;;1191   
;;;1192   		case E_FUNC_SPI3_2BIT_MODE:	
;;;1193   		{
;;;1194             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0x3<<12));
;;;1195   		}break;
;;;1196   
;;;1197   		/*---------------------------------------------------------------------------------------------------------*/
;;;1198   		/* SPI - QFN36PIN                                                                                          */
;;;1199   		/*---------------------------------------------------------------------------------------------------------*/
;;;1200   		case E_FUNC_SPI0_QFN36PIN:	
;;;1201   		{           		
;;;1202             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0xF<<0));
;;;1203    		}break;
;;;1204   
;;;1205   		case E_FUNC_SPI0_SS1_QFN36PIN:	
;;;1206   		{
;;;1207             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0x1<<1));
;;;1208   		}break;
;;;1209   
;;;1210   		case E_FUNC_SPI0_2BIT_MODE_QFN36PIN:	
;;;1211   		{
;;;1212             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0x1<<2));
;;;1213   		}break;
;;;1214   
;;;1215   		/*---------------------------------------------------------------------------------------------------------*/
;;;1216   		/* ADC                                                                                                     */
;;;1217   		/*---------------------------------------------------------------------------------------------------------*/
;;;1218   		case E_FUNC_ADC7:
;;;1219   		{
;;;1220             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<2));
;;;1221           }
;;;1222   		case E_FUNC_ADC1:
;;;1223   		case E_FUNC_ADC2:
;;;1224   		case E_FUNC_ADC3:
;;;1225   		case E_FUNC_ADC4:
;;;1226   		case E_FUNC_ADC5:
;;;1227   		case E_FUNC_ADC6:
;;;1228           {
;;;1229   		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1230           }
;;;1231   		case E_FUNC_ADC0:
;;;1232   		{
;;;1233             	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x1<<(function-E_FUNC_ADC0)));
;;;1234           }break;
;;;1235   
;;;1236     		/*---------------------------------------------------------------------------------------------------------*/
;;;1237   		/* External Interrupt                                                                                      */
;;;1238   		/*---------------------------------------------------------------------------------------------------------*/		
;;;1239   	  	case E_FUNC_EXTINT0:
;;;1240           {
;;;1241             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<3));
;;;1242           }
;;;1243   	  	case E_FUNC_EXTINT1:
;;;1244   		{	
;;;1245             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<(14+(function-E_FUNC_EXTINT0))));
;;;1246   		}break;
;;;1247   
;;;1248   		/*---------------------------------------------------------------------------------------------------------*/
;;;1249   		/* TIMER - External Counter input or toggle output pins                                                    */
;;;1250   		/*---------------------------------------------------------------------------------------------------------*/
;;;1251   		case E_FUNC_TMR0:
;;;1252   		{
;;;1253             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<8));
;;;1254   		}break;
;;;1255   	
;;;1256   		case E_FUNC_TMR1:
;;;1257   		{
;;;1258             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<9));
;;;1259             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<1));
;;;1260   		}break;
;;;1261   
;;;1262   		case E_FUNC_TMR2:
;;;1263   		{
;;;1264             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<10));
;;;1265             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<0));
;;;1266   		}break;
;;;1267   
;;;1268   		case E_FUNC_TMR3:
;;;1269   		{
;;;1270             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<11));
;;;1271             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<4));
;;;1272   		}break;
;;;1273   
;;;1274   		/*---------------------------------------------------------------------------------------------------------*/
;;;1275   		/* TIMER - External Capture input pins                                                                     */
;;;1276   		/*---------------------------------------------------------------------------------------------------------*/
;;;1277   		case E_FUNC_T0EX:
;;;1278   		{
;;;1279             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<15));
;;;1280             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<24));
;;;1281   		}break;
;;;1282   	
;;;1283   		case E_FUNC_T1EX:
;;;1284   		{
;;;1285             	outpw(&SYS->GPEMFP, inpw(&SYS->GPEMFP) | (0x1<<5));
;;;1286             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<25));
;;;1287   		}break;
;;;1288   
;;;1289   		case E_FUNC_T2EX:
;;;1290   		{
;;;1291             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<2));
;;;1292             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<26));
;;;1293   		}break;
;;;1294   
;;;1295   		case E_FUNC_T3EX:
;;;1296   		{
;;;1297             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<3));
;;;1298             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<27));
;;;1299   		}break;
;;;1300   
;;;1301   		/*---------------------------------------------------------------------------------------------------------*/
;;;1302   		/* UART                                                                                                    */
;;;1303   		/*--------------------------------------------------------------------------------------------------------*/
;;;1304   		case E_FUNC_UART0:
;;;1305   		case E_FUNC_UART0_RX_TX:
;;;1306   		case E_FUNC_UART0_RTS_CTS:
;;;1307   		case E_FUNC_UART1:
;;;1308   		case E_FUNC_UART1_RX_TX:
;;;1309   		case E_FUNC_UART1_RTS_CTS:
;;;1310   		{
;;;1311               if ((function >= E_FUNC_UART0) && (function <= E_FUNC_UART0_RTS_CTS))
;;;1312                   u8Offset = 0;
;;;1313               else
;;;1314                   u8Offset = 4;                                 
;;;1315               if ((function == E_FUNC_UART0) || (function == E_FUNC_UART1))
;;;1316             	{
;;;1317                   outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0xF<<(0+u8Offset)));
;;;1318   		  	    outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1319               }else
;;;1320               if ((function == E_FUNC_UART0_RX_TX) || (function == E_FUNC_UART1_RX_TX))
;;;1321               {
;;;1322                   outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x3<<(0+u8Offset)));
;;;1323               }else
;;;1324               if ((function == E_FUNC_UART0_RTS_CTS) || (function == E_FUNC_UART1_RTS_CTS))
;;;1325               {
;;;1326                   outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x3<<(2+u8Offset)));
;;;1327   		  	    outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1328               }
;;;1329   		}break;
;;;1330   
;;;1331   		case E_FUNC_UART2:
;;;1332   		{
;;;1333             	outpw(&SYS->GPDMFP, inpw(&SYS->GPDMFP) | (0x3<<14));
;;;1334           }break;
;;;1335   
;;;1336   		/*---------------------------------------------------------------------------------------------------------*/
;;;1337   		/* PWM                                                                                                     */
;;;1338   		/*---------------------------------------------------------------------------------------------------------*/
;;;1339   		case E_FUNC_PWM0:
;;;1340   		case E_FUNC_PWM1:
;;;1341   		case E_FUNC_PWM01:
;;;1342   		{
;;;1343               if (function == E_FUNC_PWM01)
;;;1344               {
;;;1345       		  	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x3<<12));
;;;1346               }else
;;;1347               {
;;;1348       		  	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x1<<(12+(function-E_FUNC_PWM0))));
000004  4601              MOV      r1,r0
000006  3928              SUBS     r1,r1,#0x28
000008  4627              MOV      r7,r4
00000a  408f              LSLS     r7,r7,r1
00000c  2105              MOVS     r1,#5                 ;1060
00000e  250f              MOVS     r5,#0xf               ;1050
000010  2603              MOVS     r6,#3                 ;1050
000012  0709              LSLS     r1,r1,#28             ;1060
000014  4ae1              LDR      r2,|L24.924|
000016  0003              MOVS     r3,r0                 ;1053
000018  f7fffffe          BL       __ARM_common_switch8
00001c  3e20262e          DCB      0x3e,0x20,0x26,0x2e
000020  34384447          DCB      0x34,0x38,0x44,0x47
000024  474f565e          DCB      0x47,0x4f,0x56,0x5e
000028  61676f75          DCB      0x61,0x67,0x6f,0x75
00002c  79828589          DCB      0x79,0x82,0x85,0x89
000030  9195989d          DCB      0x91,0x95,0x98,0x9d
000034  a9a4a4a4          DCB      0xa9,0xa4,0xa4,0xa4
000038  a4a4a4a0          DCB      0xa4,0xa4,0xa4,0xa0
00003c  afb3b9bd          DCB      0xaf,0xb3,0xb9,0xbd
000040  c5ced8e0          DCB      0xc5,0xce,0xd8,0xe0
000044  f2f9efef          DCB      0xf2,0xf9,0xef,0xef
000048  efefefef          DCB      0xef,0xef,0xef,0xef
00004c  eeedeceb          DCB      0xee,0xed,0xec,0xeb
000050  eaededec          DCB      0xea,0xed,0xed,0xec
000054  ecebebea          DCB      0xec,0xeb,0xeb,0xea
000058  eae9e8e7          DCB      0xea,0xe9,0xe8,0xe7
00005c  2000              MOVS     r0,#0                 ;1060
00005e  6308              STR      r0,[r1,#0x30]         ;1060
000060  6348              STR      r0,[r1,#0x34]         ;1061
000062  6388              STR      r0,[r1,#0x38]         ;1062
000064  63c8              STR      r0,[r1,#0x3c]         ;1063
000066  e14c              B        |L24.770|
000068  6b48              LDR      r0,[r1,#0x34]         ;1072
00006a  2301              MOVS     r3,#1                 ;1072
00006c  031b              LSLS     r3,r3,#12             ;1072
00006e  4318              ORRS     r0,r0,r3              ;1072
000070  6348              STR      r0,[r1,#0x34]         ;1072
000072  6910              LDR      r0,[r2,#0x10]         ;1073
000074  1099              ASRS     r1,r3,#2              ;1073
000076  e050              B        |L24.282|
000078  6b08              LDR      r0,[r1,#0x30]         ;1082
00007a  2203              MOVS     r2,#3                 ;1082
00007c  0212              LSLS     r2,r2,#8              ;1082
00007e  4310              ORRS     r0,r0,r2              ;1082
000080  6308              STR      r0,[r1,#0x30]         ;1082
000082  e13f              B        |L24.772|
000084  6b08              LDR      r0,[r1,#0x30]         ;1090
000086  2303              MOVS     r3,#3                 ;1090
000088  029b              LSLS     r3,r3,#10             ;1090
00008a  e0f8              B        |L24.638|
00008c  6b88              LDR      r0,[r1,#0x38]         ;1099
00008e  4328              ORRS     r0,r0,r5              ;1099
000090  6388              STR      r0,[r1,#0x38]         ;1099
000092  6b08              LDR      r0,[r1,#0x30]         ;1100
000094  2301              MOVS     r3,#1                 ;1100
000096  03db              LSLS     r3,r3,#15             ;1100
000098  4318              ORRS     r0,r0,r3              ;1100
00009a  6308              STR      r0,[r1,#0x30]         ;1100
00009c  6910              LDR      r0,[r2,#0x10]         ;1101
00009e  211f              MOVS     r1,#0x1f              ;1101
0000a0  0149              LSLS     r1,r1,#5              ;1101
0000a2  e0ba              B        |L24.538|
0000a4  6bc8              LDR      r0,[r1,#0x3c]         ;1109
0000a6  22c0              MOVS     r2,#0xc0              ;1109
0000a8  e0df              B        |L24.618|
0000aa  2806              CMP      r0,#6                 ;1118
0000ac  d000              BEQ      |L24.176|
0000ae  200e              MOVS     r0,#0xe               ;1121
                  |L24.176|
0000b0  6b8b              LDR      r3,[r1,#0x38]         ;1122
0000b2  4086              LSLS     r6,r6,r0              ;1122
0000b4  4333              ORRS     r3,r3,r6              ;1122
0000b6  638b              STR      r3,[r1,#0x38]         ;1122
0000b8  e0fb              B        |L24.690|
0000ba  6b88              LDR      r0,[r1,#0x38]         ;1131
0000bc  4328              ORRS     r0,r0,r5              ;1131
0000be  6388              STR      r0,[r1,#0x38]         ;1131
0000c0  6910              LDR      r0,[r2,#0x10]         ;1132
0000c2  21ff              MOVS     r1,#0xff              ;1132
0000c4  31e1              ADDS     r1,r1,#0xe1           ;1132
0000c6  e0dc              B        |L24.642|
0000c8  6b48              LDR      r0,[r1,#0x34]         ;1138
0000ca  2301              MOVS     r3,#1                 ;1138
0000cc  029b              LSLS     r3,r3,#10             ;1138
0000ce  4318              ORRS     r0,r0,r3              ;1138
0000d0  6348              STR      r0,[r1,#0x34]         ;1138
0000d2  6910              LDR      r0,[r2,#0x10]         ;1139
0000d4  4320              ORRS     r0,r0,r4              ;1139
0000d6  e0d5              B        |L24.644|
0000d8  6b88              LDR      r0,[r1,#0x38]         ;1144
0000da  2230              MOVS     r2,#0x30              ;1144
0000dc  e010              B        |L24.256|
0000de  6b88              LDR      r0,[r1,#0x38]         ;1149
0000e0  230f              MOVS     r3,#0xf               ;1149
0000e2  021b              LSLS     r3,r3,#8              ;1149
0000e4  4318              ORRS     r0,r0,r3              ;1149
0000e6  6388              STR      r0,[r1,#0x38]         ;1149
0000e8  e0e3              B        |L24.690|
0000ea  6b48              LDR      r0,[r1,#0x34]         ;1155
0000ec  2301              MOVS     r3,#1                 ;1155
0000ee  025b              LSLS     r3,r3,#9              ;1155
0000f0  4318              ORRS     r0,r0,r3              ;1155
0000f2  6348              STR      r0,[r1,#0x34]         ;1155
0000f4  6910              LDR      r0,[r2,#0x10]         ;1156
0000f6  2102              MOVS     r1,#2                 ;1156
0000f8  e08f              B        |L24.538|
0000fa  6b88              LDR      r0,[r1,#0x38]         ;1161
0000fc  2203              MOVS     r2,#3                 ;1161
0000fe  0312              LSLS     r2,r2,#12             ;1161
                  |L24.256|
000100  4310              ORRS     r0,r0,r2              ;1144
                  |L24.258|
000102  6388              STR      r0,[r1,#0x38]         ;1144
000104  e0fe              B        |L24.772|
000106  6bc8              LDR      r0,[r1,#0x3c]         ;1166
000108  4328              ORRS     r0,r0,r5              ;1166
                  |L24.266|
00010a  63c8              STR      r0,[r1,#0x3c]         ;1109
00010c  e0fa              B        |L24.772|
00010e  6b08              LDR      r0,[r1,#0x30]         ;1171
000110  2380              MOVS     r3,#0x80              ;1171
000112  4318              ORRS     r0,r0,r3              ;1171
000114  6308              STR      r0,[r1,#0x30]         ;1171
000116  6910              LDR      r0,[r2,#0x10]         ;1172
000118  2104              MOVS     r1,#4                 ;1172
                  |L24.282|
00011a  4308              ORRS     r0,r0,r1              ;1172
                  |L24.284|
00011c  6110              STR      r0,[r2,#0x10]         ;1172
00011e  e0c8              B        |L24.690|
000120  6bc8              LDR      r0,[r1,#0x3c]         ;1178
000122  2230              MOVS     r2,#0x30              ;1178
000124  e0a1              B        |L24.618|
000126  6bca              LDR      r2,[r1,#0x3c]         ;1183
000128  200f              MOVS     r0,#0xf               ;1183
00012a  0200              LSLS     r0,r0,#8              ;1183
00012c  e010              B        |L24.336|
00012e  6b48              LDR      r0,[r1,#0x34]         ;1188
000130  2301              MOVS     r3,#1                 ;1188
000132  039b              LSLS     r3,r3,#14             ;1188
000134  4318              ORRS     r0,r0,r3              ;1188
000136  6348              STR      r0,[r1,#0x34]         ;1188
000138  6910              LDR      r0,[r2,#0x10]         ;1189
00013a  2108              MOVS     r1,#8                 ;1189
00013c  e06d              B        |L24.538|
00013e  6bc8              LDR      r0,[r1,#0x3c]         ;1194
000140  2203              MOVS     r2,#3                 ;1194
000142  0312              LSLS     r2,r2,#12             ;1194
000144  e091              B        |L24.618|
000146  6b88              LDR      r0,[r1,#0x38]         ;1202
000148  4328              ORRS     r0,r0,r5              ;1202
00014a  e7da              B        |L24.258|
00014c  6bca              LDR      r2,[r1,#0x3c]         ;1207
00014e  2002              MOVS     r0,#2                 ;1207
                  |L24.336|
000150  4302              ORRS     r2,r2,r0              ;1183
000152  63ca              STR      r2,[r1,#0x3c]         ;1183
000154  e0d6              B        |L24.772|
000156  6bc8              LDR      r0,[r1,#0x3c]         ;1212
000158  2204              MOVS     r2,#4                 ;1212
00015a  e086              B        |L24.618|
00015c  6913              LDR      r3,[r2,#0x10]         ;1220
00015e  2504              MOVS     r5,#4                 ;1220
000160  43ab              BICS     r3,r3,r5              ;1220
000162  6113              STR      r3,[r2,#0x10]         ;1220
000164  6913              LDR      r3,[r2,#0x10]         ;1229
000166  2501              MOVS     r5,#1                 ;1229
000168  02ed              LSLS     r5,r5,#11             ;1229
00016a  43ab              BICS     r3,r3,r5              ;1229
00016c  6113              STR      r3,[r2,#0x10]         ;1229
00016e  6b0a              LDR      r2,[r1,#0x30]         ;1233
000170  3817              SUBS     r0,r0,#0x17           ;1233
000172  4084              LSLS     r4,r4,r0              ;1233
000174  4322              ORRS     r2,r2,r4              ;1233
000176  630a              STR      r2,[r1,#0x30]         ;1233
000178  e0c4              B        |L24.772|
00017a  6913              LDR      r3,[r2,#0x10]         ;1241
00017c  2508              MOVS     r5,#8                 ;1241
00017e  43ab              BICS     r3,r3,r5              ;1241
000180  6113              STR      r3,[r2,#0x10]         ;1241
000182  6b4a              LDR      r2,[r1,#0x34]         ;1245
000184  3811              SUBS     r0,r0,#0x11           ;1245
000186  4084              LSLS     r4,r4,r0              ;1245
000188  4322              ORRS     r2,r2,r4              ;1245
00018a  634a              STR      r2,[r1,#0x34]         ;1245
00018c  e0ba              B        |L24.772|
00018e  6b48              LDR      r0,[r1,#0x34]         ;1253
000190  22ff              MOVS     r2,#0xff              ;1253
000192  3201              ADDS     r2,#1                 ;1253
000194  e0fd              B        |L24.914|
000196  6b48              LDR      r0,[r1,#0x34]         ;1258
000198  2301              MOVS     r3,#1                 ;1258
00019a  025b              LSLS     r3,r3,#9              ;1258
00019c  4318              ORRS     r0,r0,r3              ;1258
00019e  6348              STR      r0,[r1,#0x34]         ;1258
0001a0  6911              LDR      r1,[r2,#0x10]         ;1259
0001a2  2002              MOVS     r0,#2                 ;1259
0001a4  e00f              B        |L24.454|
0001a6  6b48              LDR      r0,[r1,#0x34]         ;1264
0001a8  2301              MOVS     r3,#1                 ;1264
0001aa  029b              LSLS     r3,r3,#10             ;1264
0001ac  4318              ORRS     r0,r0,r3              ;1264
0001ae  6348              STR      r0,[r1,#0x34]         ;1264
0001b0  6910              LDR      r0,[r2,#0x10]         ;1265
0001b2  0840              LSRS     r0,r0,#1              ;1265
0001b4  0040              LSLS     r0,r0,#1              ;1265
0001b6  e065              B        |L24.644|
0001b8  6b48              LDR      r0,[r1,#0x34]         ;1270
0001ba  2301              MOVS     r3,#1                 ;1270
0001bc  02db              LSLS     r3,r3,#11             ;1270
0001be  4318              ORRS     r0,r0,r3              ;1270
0001c0  6348              STR      r0,[r1,#0x34]         ;1270
0001c2  6911              LDR      r1,[r2,#0x10]         ;1271
0001c4  2010              MOVS     r0,#0x10              ;1271
                  |L24.454|
0001c6  4381              BICS     r1,r1,r0              ;1259
0001c8  6111              STR      r1,[r2,#0x10]         ;1259
0001ca  e09b              B        |L24.772|
0001cc  6b48              LDR      r0,[r1,#0x34]         ;1279
0001ce  2301              MOVS     r3,#1                 ;1279
0001d0  03db              LSLS     r3,r3,#15             ;1279
0001d2  4318              ORRS     r0,r0,r3              ;1279
0001d4  6348              STR      r0,[r1,#0x34]         ;1279
0001d6  6910              LDR      r0,[r2,#0x10]         ;1280
0001d8  0259              LSLS     r1,r3,#9              ;1280
0001da  e01e              B        |L24.538|
0001dc  6810              LDR      r0,[r2,#0]            ;1285
0001de  2120              MOVS     r1,#0x20              ;1285
0001e0  4308              ORRS     r0,r0,r1              ;1285
0001e2  6010              STR      r0,[r2,#0]            ;1285
0001e4  6910              LDR      r0,[r2,#0x10]         ;1286
0001e6  0509              LSLS     r1,r1,#20             ;1286
0001e8  e017              B        |L24.538|
0001ea  e0d4              B        |L24.918|
0001ec  e091              B        |L24.786|
0001ee  e0a1              B        |L24.820|
0001f0  e080              B        |L24.756|
0001f2  e062              B        |L24.698|
0001f4  e048              B        |L24.648|
0001f6  e03a              B        |L24.622|
0001f8  e034              B        |L24.612|
0001fa  e010              B        |L24.542|
0001fc  e007              B        |L24.526|
0001fe  e7ff              B        |L24.512|
                  |L24.512|
000200  6b48              LDR      r0,[r1,#0x34]         ;1291
000202  2304              MOVS     r3,#4                 ;1291
000204  4318              ORRS     r0,r0,r3              ;1291
000206  6348              STR      r0,[r1,#0x34]         ;1291
000208  6910              LDR      r0,[r2,#0x10]         ;1292
00020a  0619              LSLS     r1,r3,#24             ;1292
00020c  e005              B        |L24.538|
                  |L24.526|
00020e  6b48              LDR      r0,[r1,#0x34]         ;1297
000210  2308              MOVS     r3,#8                 ;1297
000212  4318              ORRS     r0,r0,r3              ;1297
000214  6348              STR      r0,[r1,#0x34]         ;1297
000216  6910              LDR      r0,[r2,#0x10]         ;1298
000218  0619              LSLS     r1,r3,#24             ;1298
                  |L24.538|
00021a  4308              ORRS     r0,r0,r1              ;1298
00021c  e032              B        |L24.644|
                  |L24.542|
00021e  4603              MOV      r3,r0                 ;1311
000220  3b29              SUBS     r3,r3,#0x29           ;1311
000222  2b02              CMP      r3,#2                 ;1311
000224  d801              BHI      |L24.554|
000226  2300              MOVS     r3,#0                 ;1312
000228  e000              B        |L24.556|
                  |L24.554|
00022a  2304              MOVS     r3,#4                 ;1314
                  |L24.556|
00022c  2829              CMP      r0,#0x29              ;1315
00022e  d00a              BEQ      |L24.582|
000230  282c              CMP      r0,#0x2c              ;1315
000232  d008              BEQ      |L24.582|
000234  282a              CMP      r0,#0x2a              ;1320
000236  d00a              BEQ      |L24.590|
000238  282d              CMP      r0,#0x2d              ;1320
00023a  d008              BEQ      |L24.590|
00023c  282b              CMP      r0,#0x2b              ;1324
00023e  d00b              BEQ      |L24.600|
000240  282e              CMP      r0,#0x2e              ;1324
000242  d009              BEQ      |L24.600|
000244  e05e              B        |L24.772|
                  |L24.582|
000246  6b48              LDR      r0,[r1,#0x34]         ;1317
000248  409d              LSLS     r5,r5,r3              ;1317
00024a  4328              ORRS     r0,r0,r5              ;1317
00024c  e008              B        |L24.608|
                  |L24.590|
00024e  6b48              LDR      r0,[r1,#0x34]         ;1322
000250  409e              LSLS     r6,r6,r3              ;1322
000252  4330              ORRS     r0,r0,r6              ;1322
                  |L24.596|
000254  6348              STR      r0,[r1,#0x34]         ;1322
000256  e055              B        |L24.772|
                  |L24.600|
000258  6b48              LDR      r0,[r1,#0x34]         ;1326
00025a  1c9b              ADDS     r3,r3,#2              ;1326
00025c  409e              LSLS     r6,r6,r3              ;1326
00025e  4330              ORRS     r0,r0,r6              ;1326
                  |L24.608|
000260  6348              STR      r0,[r1,#0x34]         ;1317
000262  e026              B        |L24.690|
                  |L24.612|
000264  6bc8              LDR      r0,[r1,#0x3c]         ;1333
000266  2203              MOVS     r2,#3                 ;1333
000268  0392              LSLS     r2,r2,#14             ;1333
                  |L24.618|
00026a  4310              ORRS     r0,r0,r2              ;1333
00026c  e74d              B        |L24.266|
                  |L24.622|
00026e  2830              CMP      r0,#0x30              ;1343
000270  6b08              LDR      r0,[r1,#0x30]
000272  d002              BEQ      |L24.634|
000274  4338              ORRS     r0,r0,r7
                  |L24.630|
000276  6308              STR      r0,[r1,#0x30]
000278  e01b              B        |L24.690|
                  |L24.634|
00027a  2303              MOVS     r3,#3                 ;1345
00027c  031b              LSLS     r3,r3,#12             ;1345
                  |L24.638|
00027e  4318              ORRS     r0,r0,r3              ;1090
000280  e7f9              B        |L24.630|
                  |L24.642|
;;;1349               }
;;;1350   	        outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
000282  4388              BICS     r0,r0,r1
                  |L24.644|
;;;1351   		}break;
;;;1352   
;;;1353   		case E_FUNC_PWM2:
;;;1354   		case E_FUNC_PWM3:
;;;1355   		case E_FUNC_PWM23:
;;;1356   		{
;;;1357               if (function == E_FUNC_PWM23)
;;;1358               {
;;;1359       		  	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x3<<14));
;;;1360       		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<9));
;;;1361       		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1362               }else
;;;1363               {
;;;1364       		  	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x1<<(14+(function-E_FUNC_PWM2))));
;;;1365                   if (function == E_FUNC_PWM2)
;;;1366       		  	    outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<11));
;;;1367                   else
;;;1368           		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x1<<9));
;;;1369               }
;;;1370   		}break;
;;;1371   
;;;1372   		case E_FUNC_PWM4:
;;;1373   		case E_FUNC_PWM5:
;;;1374   		case E_FUNC_PWM45:
;;;1375   		{
;;;1376               if (function == E_FUNC_PWM45)
;;;1377       		{
;;;1378                 	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<11));
;;;1379       		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<4));
;;;1380                 	outpw(&SYS->GPEMFP, inpw(&SYS->GPEMFP) | (0x1<<5));
;;;1381               }else
;;;1382               if (function == E_FUNC_PWM4)
;;;1383               {
;;;1384                 	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x1<<11));
;;;1385       		  	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x1<<4));
000284  6110              STR      r0,[r2,#0x10]
000286  e03d              B        |L24.772|
                  |L24.648|
000288  2831              CMP      r0,#0x31              ;1357
00028a  d008              BEQ      |L24.670|
00028c  6b0b              LDR      r3,[r1,#0x30]         ;1364
00028e  433b              ORRS     r3,r3,r7              ;1364
000290  630b              STR      r3,[r1,#0x30]         ;1364
000292  2836              CMP      r0,#0x36              ;1365
000294  d00d              BEQ      |L24.690|
000296  6910              LDR      r0,[r2,#0x10]         ;1368
000298  2101              MOVS     r1,#1                 ;1368
00029a  0249              LSLS     r1,r1,#9              ;1368
00029c  e7f1              B        |L24.642|
                  |L24.670|
00029e  6b08              LDR      r0,[r1,#0x30]         ;1359
0002a0  2303              MOVS     r3,#3                 ;1359
0002a2  039b              LSLS     r3,r3,#14             ;1359
0002a4  4318              ORRS     r0,r0,r3              ;1359
0002a6  6308              STR      r0,[r1,#0x30]         ;1359
0002a8  6910              LDR      r0,[r2,#0x10]         ;1360
0002aa  2101              MOVS     r1,#1                 ;1360
0002ac  0249              LSLS     r1,r1,#9              ;1360
0002ae  4388              BICS     r0,r0,r1              ;1360
0002b0  e734              B        |L24.284|
                  |L24.690|
0002b2  6910              LDR      r0,[r2,#0x10]         ;1366
0002b4  2101              MOVS     r1,#1                 ;1366
0002b6  02c9              LSLS     r1,r1,#11             ;1366
0002b8  e7e3              B        |L24.642|
                  |L24.698|
0002ba  2832              CMP      r0,#0x32              ;1376
0002bc  d006              BEQ      |L24.716|
0002be  2838              CMP      r0,#0x38              ;1382
0002c0  d010              BEQ      |L24.740|
;;;1386               }else
;;;1387               {
;;;1388                 	outpw(&SYS->GPEMFP, inpw(&SYS->GPEMFP) | (0x1<<5));
0002c2  6811              LDR      r1,[r2,#0]
0002c4  2020              MOVS     r0,#0x20
0002c6  4301              ORRS     r1,r1,r0
0002c8  6011              STR      r1,[r2,#0]
0002ca  e01b              B        |L24.772|
                  |L24.716|
0002cc  6b48              LDR      r0,[r1,#0x34]         ;1378
0002ce  2301              MOVS     r3,#1                 ;1378
0002d0  02db              LSLS     r3,r3,#11             ;1378
0002d2  4318              ORRS     r0,r0,r3              ;1378
0002d4  6348              STR      r0,[r1,#0x34]         ;1378
0002d6  6910              LDR      r0,[r2,#0x10]         ;1379
0002d8  2110              MOVS     r1,#0x10              ;1379
0002da  4308              ORRS     r0,r0,r1              ;1379
0002dc  6110              STR      r0,[r2,#0x10]         ;1379
0002de  6810              LDR      r0,[r2,#0]            ;1380
0002e0  2120              MOVS     r1,#0x20              ;1380
0002e2  e00d              B        |L24.768|
                  |L24.740|
0002e4  6b48              LDR      r0,[r1,#0x34]         ;1384
0002e6  2301              MOVS     r3,#1                 ;1384
0002e8  02db              LSLS     r3,r3,#11             ;1384
0002ea  4318              ORRS     r0,r0,r3              ;1384
0002ec  6348              STR      r0,[r1,#0x34]         ;1384
0002ee  6910              LDR      r0,[r2,#0x10]         ;1385
0002f0  2110              MOVS     r1,#0x10              ;1385
0002f2  e792              B        |L24.538|
                  |L24.756|
;;;1389               }
;;;1390   		}break;
;;;1391   
;;;1392   		case E_FUNC_PWM6:
;;;1393   		case E_FUNC_PWM7:
;;;1394   		case E_FUNC_PWM67:
;;;1395   		{
;;;1396               if (function == E_FUNC_PWM67)
0002f4  2833              CMP      r0,#0x33
0002f6  d007              BEQ      |L24.776|
;;;1397   		  	{
;;;1398                   outpw(&SYS->GPEMFP, inpw(&SYS->GPEMFP) | (0x3<<0));
;;;1399               }else
;;;1400               if (function == E_FUNC_PWM6)
0002f8  283a              CMP      r0,#0x3a
;;;1401               {
;;;1402                   outpw(&SYS->GPEMFP, inpw(&SYS->GPEMFP) | (0x1<<0));
;;;1403               }else
;;;1404               {
;;;1405                   outpw(&SYS->GPEMFP, inpw(&SYS->GPEMFP) | (0x1<<1));
0002fa  6810              LDR      r0,[r2,#0]
0002fc  d007              BEQ      |L24.782|
0002fe  2102              MOVS     r1,#2
                  |L24.768|
000300  4308              ORRS     r0,r0,r1              ;1380
                  |L24.770|
000302  6010              STR      r0,[r2,#0]            ;1402
                  |L24.772|
;;;1406               }
;;;1407   		}break;
;;;1408   
;;;1409   		/*---------------------------------------------------------------------------------------------------------*/
;;;1410   		/* EBI                                                                                                     */
;;;1411   		/*---------------------------------------------------------------------------------------------------------*/
;;;1412   		case E_FUNC_EBI_16B:	
;;;1413   		{
;;;1414   			// Enable nWRH & nWRL for support Byte-Write in 16bit Data Width Device(SRAM) 
;;;1415             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x3<<2));
;;;1416             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x3<<13));			
;;;1417   		
;;;1418   			// Enable EBI AD High-byte, bit 15~8
;;;1419             	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x703E));
;;;1420             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0xFF<<16));			
;;;1421   		}
;;;1422   				
;;;1423   		case E_FUNC_EBI_8B:	
;;;1424   		{
;;;1425               if (function == E_FUNC_EBI_8B)
;;;1426               {
;;;1427       			// Disable nWRH & nWRL for support Byte-Write in 16bit Data Width Device(SRAM) 
;;;1428                 	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) & ~(0x3<<2));
;;;1429                 	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0x3<<13));			
;;;1430       		
;;;1431       			// Disable EBI AD High-byte, bit 15~8
;;;1432                 	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) & ~(0x703E));
;;;1433                 	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) & ~(0xFF<<16));			
;;;1434               }
;;;1435   
;;;1436   			// Enable EBI_EN and EBI_MCLK_EN
;;;1437             	outpw(&SYS->ALTMFP, inpw(&SYS->ALTMFP) | (0x3<<11));			
;;;1438             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0x1<<8));
;;;1439   			
;;;1440   			// Enable nRD/nWR/ALE/nCS for EBI
;;;1441             	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x3<<10));
;;;1442             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x3<<6));
;;;1443   			
;;;1444   			// Enable EBI AD Low-byte, bit 7~0
;;;1445             	outpw(&SYS->GPAMFP, inpw(&SYS->GPAMFP) | (0x3<<6));
;;;1446             	outpw(&SYS->GPCMFP, inpw(&SYS->GPCMFP) | (0x3<<6) | (0x3<<14));
;;;1447             	outpw(&SYS->GPBMFP, inpw(&SYS->GPBMFP) | (0x3<<12));
;;;1448   		}break;
;;;1449   
;;;1450   		default:
;;;1451   			return E_DRVGPIO_ARGUMENT;
;;;1452   	}
;;;1453   
;;;1454   	return E_SUCCESS;
000304  2000              MOVS     r0,#0
;;;1455   }
000306  bdf0              POP      {r4-r7,pc}
                  |L24.776|
000308  6810              LDR      r0,[r2,#0]            ;1398
00030a  4330              ORRS     r0,r0,r6              ;1398
00030c  e7f9              B        |L24.770|
                  |L24.782|
00030e  4320              ORRS     r0,r0,r4              ;1402
000310  e7f7              B        |L24.770|
                  |L24.786|
000312  6b48              LDR      r0,[r1,#0x34]         ;1415
000314  230c              MOVS     r3,#0xc               ;1415
000316  4318              ORRS     r0,r0,r3              ;1415
000318  6348              STR      r0,[r1,#0x34]         ;1415
00031a  6910              LDR      r0,[r2,#0x10]         ;1416
00031c  02db              LSLS     r3,r3,#11             ;1416
00031e  4318              ORRS     r0,r0,r3              ;1416
000320  6110              STR      r0,[r2,#0x10]         ;1416
000322  6b08              LDR      r0,[r1,#0x30]         ;1419
000324  4b1e              LDR      r3,|L24.928|
000326  4318              ORRS     r0,r0,r3              ;1419
000328  6308              STR      r0,[r1,#0x30]         ;1419
00032a  6910              LDR      r0,[r2,#0x10]         ;1420
00032c  23ff              MOVS     r3,#0xff              ;1420
00032e  041b              LSLS     r3,r3,#16             ;1420
000330  4318              ORRS     r0,r0,r3              ;1420
000332  e012              B        |L24.858|
                  |L24.820|
000334  283c              CMP      r0,#0x3c              ;1425
000336  d111              BNE      |L24.860|
000338  6b48              LDR      r0,[r1,#0x34]         ;1428
00033a  230c              MOVS     r3,#0xc               ;1428
00033c  4398              BICS     r0,r0,r3              ;1428
00033e  6348              STR      r0,[r1,#0x34]         ;1428
000340  6910              LDR      r0,[r2,#0x10]         ;1429
000342  02db              LSLS     r3,r3,#11             ;1429
000344  4398              BICS     r0,r0,r3              ;1429
000346  6110              STR      r0,[r2,#0x10]         ;1429
000348  6b08              LDR      r0,[r1,#0x30]         ;1432
00034a  4b15              LDR      r3,|L24.928|
00034c  43db              MVNS     r3,r3                 ;1432
00034e  4018              ANDS     r0,r0,r3              ;1432
000350  6308              STR      r0,[r1,#0x30]         ;1432
000352  6910              LDR      r0,[r2,#0x10]         ;1433
000354  23ff              MOVS     r3,#0xff              ;1433
000356  041b              LSLS     r3,r3,#16             ;1433
000358  4398              BICS     r0,r0,r3              ;1433
                  |L24.858|
00035a  6110              STR      r0,[r2,#0x10]         ;1420
                  |L24.860|
00035c  6910              LDR      r0,[r2,#0x10]         ;1437
00035e  2303              MOVS     r3,#3                 ;1437
000360  02db              LSLS     r3,r3,#11             ;1437
000362  4318              ORRS     r0,r0,r3              ;1437
000364  6110              STR      r0,[r2,#0x10]         ;1437
000366  6b88              LDR      r0,[r1,#0x38]         ;1438
000368  22ff              MOVS     r2,#0xff              ;1438
00036a  3201              ADDS     r2,#1                 ;1438
00036c  4310              ORRS     r0,r0,r2              ;1438
00036e  6388              STR      r0,[r1,#0x38]         ;1438
000370  6b08              LDR      r0,[r1,#0x30]         ;1441
000372  105a              ASRS     r2,r3,#1              ;1441
000374  4310              ORRS     r0,r0,r2              ;1441
000376  6308              STR      r0,[r1,#0x30]         ;1441
000378  6b4a              LDR      r2,[r1,#0x34]         ;1442
00037a  20c0              MOVS     r0,#0xc0              ;1442
00037c  4302              ORRS     r2,r2,r0              ;1442
00037e  634a              STR      r2,[r1,#0x34]         ;1442
000380  6b0a              LDR      r2,[r1,#0x30]         ;1445
000382  4302              ORRS     r2,r2,r0              ;1445
000384  630a              STR      r2,[r1,#0x30]         ;1445
000386  6b88              LDR      r0,[r1,#0x38]         ;1446
000388  4a06              LDR      r2,|L24.932|
00038a  4310              ORRS     r0,r0,r2              ;1446
00038c  6388              STR      r0,[r1,#0x38]         ;1446
00038e  6b48              LDR      r0,[r1,#0x34]         ;1447
000390  005a              LSLS     r2,r3,#1              ;1447
                  |L24.914|
000392  4310              ORRS     r0,r0,r2              ;1447
000394  e75e              B        |L24.596|
                  |L24.918|
000396  4804              LDR      r0,|L24.936|
000398  bdf0              POP      {r4-r7,pc}
;;;1456   
                          ENDP

00039a  0000              DCW      0x0000
                  |L24.924|
                          DCD      0x50000040
                  |L24.928|
                          DCD      0x0000703e
                  |L24.932|
                          DCD      0x0000c0c0
                  |L24.936|
                          DCD      0xffff8901

                          AREA ||i.DrvGPIO_Open||, CODE, READONLY, ALIGN=2

                  DrvGPIO_Open PROC
;;;115    /*---------------------------------------------------------------------------------------------------------*/
;;;116    int32_t DrvGPIO_Open(E_DRVGPIO_PORT port, int32_t i32Bit, E_DRVGPIO_IO mode)
000000  b518              PUSH     {r3,r4,lr}
;;;117    {
000002  4603              MOV      r3,r0
;;;118        volatile uint32_t u32Reg;
;;;119        
;;;120        if ((i32Bit < 0) || (i32Bit > 16))
;;;121        {
;;;122            return E_DRVGPIO_ARGUMENT;
000004  4815              LDR      r0,|L25.92|
000006  2911              CMP      r1,#0x11              ;120
000008  d214              BCS      |L25.52|
;;;123        }    
;;;124    
;;;125        u32Reg = (uint32_t)&GPIOA->PMD + (port*PORT_OFFSET);    
00000a  4c15              LDR      r4,|L25.96|
00000c  019b              LSLS     r3,r3,#6
00000e  191b              ADDS     r3,r3,r4
;;;126        if ((mode == E_IO_INPUT) || (mode == E_IO_OUTPUT) || (mode == E_IO_OPENDRAIN))
;;;127        {
;;;128            outpw(u32Reg, inpw(u32Reg) & ~(0x3<<(i32Bit*2)));
000010  9300              STR      r3,[sp,#0]
000012  2303              MOVS     r3,#3
000014  0049              LSLS     r1,r1,#1
000016  408b              LSLS     r3,r3,r1
000018  2a00              CMP      r2,#0                 ;126
00001a  d00c              BEQ      |L25.54|
00001c  2a01              CMP      r2,#1                 ;126
00001e  d00a              BEQ      |L25.54|
000020  2a02              CMP      r2,#2                 ;126
000022  d008              BEQ      |L25.54|
;;;129            if (mode == E_IO_OUTPUT)
;;;130            {
;;;131                outpw(u32Reg, inpw(u32Reg) | (0x1<<(i32Bit*2)));
;;;132            }else
;;;133            if (mode == E_IO_OPENDRAIN) 
;;;134            {
;;;135                outpw(u32Reg, inpw(u32Reg) | (0x2<<(i32Bit*2)));
;;;136            }
;;;137        }else
;;;138    	if (mode == E_IO_QUASI)
000024  2a03              CMP      r2,#3
000026  d105              BNE      |L25.52|
;;;139        {
;;;140            outpw(u32Reg, inpw(u32Reg) | (0x3<<(i32Bit*2)));
000028  9800              LDR      r0,[sp,#0]
00002a  6800              LDR      r0,[r0,#0]
00002c  4318              ORRS     r0,r0,r3
                  |L25.46|
00002e  9900              LDR      r1,[sp,#0]
000030  6008              STR      r0,[r1,#0]
                  |L25.50|
;;;141        }else
;;;142        {
;;;143            return E_DRVGPIO_ARGUMENT;
;;;144        }
;;;145            
;;;146    	return E_SUCCESS;
000032  2000              MOVS     r0,#0
                  |L25.52|
;;;147    }
000034  bd18              POP      {r3,r4,pc}
                  |L25.54|
000036  9800              LDR      r0,[sp,#0]            ;128
000038  6800              LDR      r0,[r0,#0]            ;128
00003a  4398              BICS     r0,r0,r3              ;128
00003c  9b00              LDR      r3,[sp,#0]            ;128
00003e  6018              STR      r0,[r3,#0]            ;128
000040  2a01              CMP      r2,#1                 ;129
000042  d006              BEQ      |L25.82|
000044  2a02              CMP      r2,#2                 ;133
000046  d1f4              BNE      |L25.50|
000048  9800              LDR      r0,[sp,#0]            ;135
00004a  6800              LDR      r0,[r0,#0]            ;135
                  |L25.76|
00004c  408a              LSLS     r2,r2,r1              ;131
00004e  4310              ORRS     r0,r0,r2              ;131
000050  e7ed              B        |L25.46|
                  |L25.82|
000052  9800              LDR      r0,[sp,#0]            ;131
000054  6800              LDR      r0,[r0,#0]            ;131
000056  2201              MOVS     r2,#1                 ;131
000058  e7f8              B        |L25.76|
;;;148    
                          ENDP

00005a  0000              DCW      0x0000
                  |L25.92|
                          DCD      0xffff8901
                  |L25.96|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_SetBit||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetBit PROC
;;;193    /*---------------------------------------------------------------------------------------------------------*/
;;;194    int32_t DrvGPIO_SetBit(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  2911              CMP      r1,#0x11
;;;195    {
000002  d301              BCC      |L26.8|
;;;196    	GPIO_T * tGPIO;
;;;197    
;;;198        if ((i32Bit < 0) || (i32Bit > 16))
;;;199        {
;;;200            return E_DRVGPIO_ARGUMENT;
000004  4805              LDR      r0,|L26.28|
;;;201        }
;;;202    
;;;203    	tGPIO = (GPIO_T *)((uint32_t)GPIOA + (port*PORT_OFFSET));  
;;;204    
;;;205    	tGPIO->DOUT |= (1 << i32Bit);
;;;206    
;;;207    	return E_SUCCESS;
;;;208    }
000006  4770              BX       lr
                  |L26.8|
000008  4a05              LDR      r2,|L26.32|
00000a  0180              LSLS     r0,r0,#6              ;203
00000c  1880              ADDS     r0,r0,r2              ;203
00000e  6882              LDR      r2,[r0,#8]            ;205
000010  2301              MOVS     r3,#1                 ;205
000012  408b              LSLS     r3,r3,r1              ;205
000014  431a              ORRS     r2,r2,r3              ;205
000016  6082              STR      r2,[r0,#8]            ;205
000018  2000              MOVS     r0,#0                 ;207
00001a  4770              BX       lr
;;;209    
                          ENDP

                  |L26.28|
                          DCD      0xffff8901
                  |L26.32|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_SetBitMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetBitMask PROC
;;;378    /*---------------------------------------------------------------------------------------------------------*/
;;;379    int32_t DrvGPIO_SetBitMask(E_DRVGPIO_PORT port, int32_t i32Bit)
000000  4a06              LDR      r2,|L27.28|
;;;380    {
000002  b508              PUSH     {r3,lr}
;;;381        volatile uint32_t u32Reg;
;;;382    
;;;383        u32Reg = (uint32_t)&GPIOA->DMASK + (port*PORT_OFFSET);    
000004  0180              LSLS     r0,r0,#6
000006  1880              ADDS     r0,r0,r2
;;;384    
;;;385    	outpw(u32Reg, inpw(u32Reg) | (1<<i32Bit));
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  408a              LSLS     r2,r2,r1
000010  9900              LDR      r1,[sp,#0]
000012  4310              ORRS     r0,r0,r2
000014  6008              STR      r0,[r1,#0]
;;;386    
;;;387    	return E_SUCCESS;
000016  2000              MOVS     r0,#0
;;;388    }
000018  bd08              POP      {r3,pc}
;;;389    
                          ENDP

00001a  0000              DCW      0x0000
                  |L27.28|
                          DCD      0x5000400c

                          AREA ||i.DrvGPIO_SetDebounceTime||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetDebounceTime PROC
;;;612    /*---------------------------------------------------------------------------------------------------------*/
;;;613    int32_t DrvGPIO_SetDebounceTime(uint32_t u32CycleSelection, E_DRVGPIO_DBCLKSRC ClockSource)
000000  280f              CMP      r0,#0xf
;;;614    {
000002  d901              BLS      |L28.8|
;;;615        /* Maximum debounce time is 2^(15)*(clk src) */
;;;616        if (u32CycleSelection > 15)
;;;617        {
;;;618            return E_DRVGPIO_ARGUMENT;
000004  4809              LDR      r0,|L28.44|
;;;619        }
;;;620        
;;;621    	GPIO_DBNCECON->DBNCECON.DBCLKSEL = u32CycleSelection ; 
;;;622    
;;;623    	GPIO_DBNCECON->DBNCECON.DBCLKSRC = ClockSource ; 
;;;624    
;;;625        return E_SUCCESS;
;;;626    }
000006  4770              BX       lr
                  |L28.8|
000008  4a09              LDR      r2,|L28.48|
00000a  6813              LDR      r3,[r2,#0]            ;621
00000c  0700              LSLS     r0,r0,#28             ;621
00000e  091b              LSRS     r3,r3,#4              ;621
000010  011b              LSLS     r3,r3,#4              ;621
000012  0f00              LSRS     r0,r0,#28             ;621
000014  4303              ORRS     r3,r3,r0              ;621
000016  6013              STR      r3,[r2,#0]            ;621
000018  6810              LDR      r0,[r2,#0]            ;623
00001a  2310              MOVS     r3,#0x10              ;623
00001c  07c9              LSLS     r1,r1,#31             ;623
00001e  4398              BICS     r0,r0,r3              ;623
000020  0ec9              LSRS     r1,r1,#27             ;623
000022  4308              ORRS     r0,r0,r1              ;623
000024  6010              STR      r0,[r2,#0]            ;623
000026  2000              MOVS     r0,#0                 ;625
000028  4770              BX       lr
;;;627    
                          ENDP

00002a  0000              DCW      0x0000
                  |L28.44|
                          DCD      0xffff8901
                  |L28.48|
                          DCD      0x50004180

                          AREA ||i.DrvGPIO_SetIntCallback||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetIntCallback PROC
;;;768    /*---------------------------------------------------------------------------------------------------------*/
;;;769    void DrvGPIO_SetIntCallback(GPIO_GPAB_CALLBACK pfGPABCallback, GPIO_GPCDE_CALLBACK pfGPCDECallback)
000000  4a01              LDR      r2,|L29.8|
;;;770    {
;;;771        _pfGPABCallback  = (void (*)(uint32_t, uint32_t))pfGPABCallback;
000002  c203              STM      r2!,{r0,r1}
;;;772        _pfGPCDECallback = (void (*)(uint32_t, uint32_t, uint32_t))pfGPCDECallback;    
;;;773    }
000004  4770              BX       lr
;;;774    
                          ENDP

000006  0000              DCW      0x0000
                  |L29.8|
                          DCD      ||.data||

                          AREA ||i.DrvGPIO_SetPortBits||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetPortBits PROC
;;;281    /*---------------------------------------------------------------------------------------------------------*/
;;;282    int32_t DrvGPIO_SetPortBits(E_DRVGPIO_PORT port,int32_t i32Data)
000000  4a02              LDR      r2,|L30.12|
;;;283    {
;;;284        GPIO_T * tGPIO;
;;;285    
;;;286    	tGPIO = (GPIO_T *)((uint32_t)GPIOA + (port*PORT_OFFSET));  
000002  0180              LSLS     r0,r0,#6
000004  1880              ADDS     r0,r0,r2
;;;287    
;;;288    	tGPIO->DOUT = i32Data;
000006  6081              STR      r1,[r0,#8]
;;;289    
;;;290        return E_SUCCESS;
000008  2000              MOVS     r0,#0
;;;291    }
00000a  4770              BX       lr
;;;292    
                          ENDP

                  |L30.12|
                          DCD      0x50004000

                          AREA ||i.DrvGPIO_SetPortMask||, CODE, READONLY, ALIGN=2

                  DrvGPIO_SetPortMask PROC
;;;453    /*---------------------------------------------------------------------------------------------------------*/
;;;454    int32_t DrvGPIO_SetPortMask(E_DRVGPIO_PORT port, int32_t i32MaskData)
000000  0182              LSLS     r2,r0,#6
000002  4803              LDR      r0,|L31.16|
000004  1810              ADDS     r0,r2,r0
000006  68c2              LDR      r2,[r0,#0xc]
;;;455    {
;;;456        outpw((uint32_t)&GPIOA->DMASK + (port*PORT_OFFSET), DrvGPIO_GetPortMask(port) | i32MaskData);
000008  430a              ORRS     r2,r2,r1
00000a  60c2              STR      r2,[r0,#0xc]
;;;457    
;;;458        return E_SUCCESS;
00000c  2000              MOVS     r0,#0
;;;459    }
00000e  4770              BX       lr
;;;460    
                          ENDP

                  |L31.16|
                          DCD      0x50004000

                          AREA ||i.EINT0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EINT0_IRQHandler PROC
;;;74     /*---------------------------------------------------------------------------------------------------------*/
;;;75     void EINT0_IRQHandler(void)
000000  2001              MOVS     r0,#1
;;;76     {
;;;77         /* EINT0 = GPB14. Clear the interrupt */
;;;78       	GPIOB->ISRC  = 1UL << 14;
000002  4904              LDR      r1,|L32.20|
000004  0380              LSLS     r0,r0,#14
000006  6208              STR      r0,[r1,#0x20]
;;;79     	if ( _pfEINT0Callback )
000008  4803              LDR      r0,|L32.24|
00000a  6880              LDR      r0,[r0,#8]  ; _pfEINT0Callback
00000c  2800              CMP      r0,#0
00000e  d000              BEQ      |L32.18|
;;;80             _pfEINT0Callback();
000010  4700              BX       r0
                  |L32.18|
;;;81     }
000012  4770              BX       lr
;;;82     
                          ENDP

                  |L32.20|
                          DCD      0x50004040
                  |L32.24|
                          DCD      ||.data||

                          AREA ||i.EINT1_IRQHandler||, CODE, READONLY, ALIGN=2

                  EINT1_IRQHandler PROC
;;;85     /*---------------------------------------------------------------------------------------------------------*/
;;;86     void EINT1_IRQHandler(void)
000000  2001              MOVS     r0,#1
;;;87     {
;;;88         /* EINT0 = GPB15. Clear the interrupt */
;;;89       	GPIOB->ISRC  = 1UL << 15;
000002  4904              LDR      r1,|L33.20|
000004  03c0              LSLS     r0,r0,#15
000006  6208              STR      r0,[r1,#0x20]
;;;90     	if ( _pfEINT1Callback )
000008  4803              LDR      r0,|L33.24|
00000a  68c0              LDR      r0,[r0,#0xc]  ; _pfEINT1Callback
00000c  2800              CMP      r0,#0
00000e  d000              BEQ      |L33.18|
;;;91             _pfEINT1Callback();
000010  4700              BX       r0
                  |L33.18|
;;;92     }
000012  4770              BX       lr
;;;93     
                          ENDP

                  |L33.20|
                          DCD      0x50004040
                  |L33.24|
                          DCD      ||.data||

                          AREA ||i.GPAB_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPAB_IRQHandler PROC
;;;29     /*---------------------------------------------------------------------------------------------------------*/
;;;30     void GPAB_IRQHandler(void)
000000  490c              LDR      r1,|L34.52|
;;;31     {
000002  b082              SUB      sp,sp,#8
;;;32     	volatile uint32_t u32GPAStatus, u32GPBStatus;
;;;33     	
;;;34         /* Keep the interrupt source */
;;;35     	u32GPAStatus = GPIOA->ISRC;
000004  6a08              LDR      r0,[r1,#0x20]
;;;36     	u32GPBStatus = GPIOB->ISRC;
000006  9001              STR      r0,[sp,#4]
000008  480a              LDR      r0,|L34.52|
00000a  3040              ADDS     r0,r0,#0x40
00000c  6a02              LDR      r2,[r0,#0x20]
;;;37     
;;;38         /* Avoid to clear EINT0/EINT1 INT flag */
;;;39         u32GPBStatus = u32GPBStatus & ~(0x3 << 14);
00000e  2303              MOVS     r3,#3
000010  039b              LSLS     r3,r3,#14
000012  439a              BICS     r2,r2,r3
;;;40     
;;;41         /* Clear the interrupt */
;;;42         GPIOA->ISRC = u32GPAStatus;
000014  9200              STR      r2,[sp,#0]
000016  9a01              LDR      r2,[sp,#4]
000018  620a              STR      r2,[r1,#0x20]
;;;43         GPIOB->ISRC = u32GPBStatus;
00001a  9900              LDR      r1,[sp,#0]
00001c  6201              STR      r1,[r0,#0x20]
;;;44     
;;;45         /* Call the callback function of GPIOAB interrupt */
;;;46         if ( _pfGPABCallback )
00001e  4806              LDR      r0,|L34.56|
000020  6802              LDR      r2,[r0,#0]  ; _pfGPABCallback
000022  2a00              CMP      r2,#0
000024  d003              BEQ      |L34.46|
;;;47             _pfGPABCallback(u32GPAStatus, u32GPBStatus);    
000026  9900              LDR      r1,[sp,#0]
000028  9801              LDR      r0,[sp,#4]
00002a  b002              ADD      sp,sp,#8
00002c  4710              BX       r2
                  |L34.46|
;;;48     }
00002e  b002              ADD      sp,sp,#8
000030  4770              BX       lr
;;;49     
                          ENDP

000032  0000              DCW      0x0000
                  |L34.52|
                          DCD      0x50004000
                  |L34.56|
                          DCD      ||.data||

                          AREA ||i.GPCDE_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPCDE_IRQHandler PROC
;;;52     /*---------------------------------------------------------------------------------------------------------*/
;;;53     void GPCDE_IRQHandler(void)
000000  4a0e              LDR      r2,|L35.60|
;;;54     {
000002  b084              SUB      sp,sp,#0x10
;;;55     	volatile uint32_t u32GPCStatus, u32GPDStatus, u32GPEStatus;
;;;56     	
;;;57         /* Keep the interrupt source */
;;;58     	u32GPCStatus = GPIOC->ISRC;
000004  6a10              LDR      r0,[r2,#0x20]
;;;59     	u32GPDStatus = GPIOD->ISRC;
000006  9002              STR      r0,[sp,#8]
000008  480c              LDR      r0,|L35.60|
00000a  3040              ADDS     r0,r0,#0x40
00000c  6a01              LDR      r1,[r0,#0x20]
;;;60     	u32GPEStatus = GPIOE->ISRC;
00000e  9101              STR      r1,[sp,#4]
000010  490a              LDR      r1,|L35.60|
000012  3180              ADDS     r1,r1,#0x80
000014  6a0b              LDR      r3,[r1,#0x20]
;;;61     
;;;62         /* Clear the interrupt */
;;;63         GPIOC->ISRC = u32GPCStatus;
000016  9300              STR      r3,[sp,#0]
000018  9b02              LDR      r3,[sp,#8]
00001a  6213              STR      r3,[r2,#0x20]
;;;64         GPIOD->ISRC = u32GPDStatus;
00001c  9a01              LDR      r2,[sp,#4]
00001e  6202              STR      r2,[r0,#0x20]
;;;65         GPIOE->ISRC = u32GPEStatus;
000020  9800              LDR      r0,[sp,#0]
000022  6208              STR      r0,[r1,#0x20]
;;;66     
;;;67         /* Call the callback function of GPIOAB interrupt */
;;;68         if ( _pfGPCDECallback )
000024  4806              LDR      r0,|L35.64|
000026  6843              LDR      r3,[r0,#4]  ; _pfGPCDECallback
000028  2b00              CMP      r3,#0
00002a  d004              BEQ      |L35.54|
;;;69             _pfGPCDECallback(u32GPCStatus, u32GPDStatus, u32GPEStatus);    
00002c  9a00              LDR      r2,[sp,#0]
00002e  9901              LDR      r1,[sp,#4]
000030  9802              LDR      r0,[sp,#8]
000032  b004              ADD      sp,sp,#0x10
000034  4718              BX       r3
                  |L35.54|
;;;70     }
000036  b004              ADD      sp,sp,#0x10
000038  4770              BX       lr
;;;71     
                          ENDP

00003a  0000              DCW      0x0000
                  |L35.60|
                          DCD      0x50004080
                  |L35.64|
                          DCD      ||.data||

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;809     */
;;;810    static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c1              LSLS     r1,r0,#27
;;;811    {
;;;812      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
000002  0ec9              LSRS     r1,r1,#27
000004  2001              MOVS     r0,#1
000006  4088              LSLS     r0,r0,r1
000008  4901              LDR      r1,|L36.16|
00000a  6008              STR      r0,[r1,#0]
;;;813    }
00000c  4770              BX       lr
;;;814    
                          ENDP

00000e  0000              DCW      0x0000
                  |L36.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;796     */
;;;797    static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c1              LSLS     r1,r0,#27
;;;798    {
;;;799      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
000002  0ec9              LSRS     r1,r1,#27
000004  2001              MOVS     r0,#1
000006  4088              LSLS     r0,r0,r1
000008  4901              LDR      r1,|L37.16|
00000a  6008              STR      r0,[r1,#0]
;;;800    }
00000c  4770              BX       lr
;;;801    
                          ENDP

00000e  0000              DCW      0x0000
                  |L37.16|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;866     */
;;;867    static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0783              LSLS     r3,r0,#30
;;;868    {
;;;869      if(IRQn < 0) {
;;;870        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
000002  22ff              MOVS     r2,#0xff
000004  0edb              LSRS     r3,r3,#27
000006  409a              LSLS     r2,r2,r3
000008  0789              LSLS     r1,r1,#30
00000a  0e09              LSRS     r1,r1,#24
00000c  4099              LSLS     r1,r1,r3
00000e  2800              CMP      r0,#0                 ;869
000010  da0b              BGE      |L38.42|
000012  0700              LSLS     r0,r0,#28
000014  0f00              LSRS     r0,r0,#28
000016  3808              SUBS     r0,r0,#8
000018  0883              LSRS     r3,r0,#2
00001a  4808              LDR      r0,|L38.60|
00001c  009b              LSLS     r3,r3,#2
00001e  1818              ADDS     r0,r3,r0
000020  69c3              LDR      r3,[r0,#0x1c]
000022  4393              BICS     r3,r3,r2
000024  430b              ORRS     r3,r3,r1
000026  61c3              STR      r3,[r0,#0x1c]
;;;871            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;872      else {
;;;873        NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
;;;874            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;875    }
000028  4770              BX       lr
                  |L38.42|
00002a  0883              LSRS     r3,r0,#2              ;873
00002c  4804              LDR      r0,|L38.64|
00002e  009b              LSLS     r3,r3,#2              ;873
000030  1818              ADDS     r0,r3,r0              ;873
000032  6803              LDR      r3,[r0,#0]            ;873
000034  4393              BICS     r3,r3,r2              ;873
000036  430b              ORRS     r3,r3,r1              ;873
000038  6003              STR      r3,[r0,#0]            ;873
00003a  4770              BX       lr
;;;876    
                          ENDP

                  |L38.60|
                          DCD      0xe000ed00
                  |L38.64|
                          DCD      0xe000e400

                          AREA ||.data||, DATA, ALIGN=2

                  _pfGPABCallback
                          DCD      0x00000000
                  _pfGPCDECallback
                          DCD      0x00000000
                  _pfEINT0Callback
                          DCD      0x00000000
                  _pfEINT1Callback
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L233.16|
00000e  461d              MOV      r5,r3
                  |L233.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP

