; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Template -I..\NUC140BSP\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\NUC140BSP\NuvotonPlatform_Keil\Include -I..\NUC140BSP\NuvotonPlatform_Keil\Include\Driver -I..\NUC140BSP\CMSIS\CM0\CoreSupport -I..\NUC140BSP\NuvotonPlatform_Keil\Include\NUC1xx-LB_002 -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\Inc\ST\STM32F10x -D__UVISION_VERSION=517 --omf_browse=.\obj\retarget.crf ..\NUC140BSP\NuvotonPlatform_Keil\Src\Driver\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;95     /*---------------------------------------------------------------------------------------------------------*/
;;;96     char GetChar(void)
000000  4803              LDR      r0,|L1.16|
                  |L1.2|
;;;97     {
;;;98     #if defined(DEBUG_ENABLE_SEMIHOST)
;;;99     # if defined ( __CC_ARM   )
;;;100        int nRet;
;;;101        while(SH_DoCommand(0x101, 0, &nRet) != 0)
;;;102        {
;;;103            if(nRet != 0)
;;;104            {
;;;105                    SH_DoCommand(0x07, 0, &nRet);
;;;106                    return (char)nRet;
;;;107            }
;;;108        }
;;;109    # else
;;;110        int nRet;
;;;111    	while(SH_DoCommand(0x7, 0, &nRet) != 0)  
;;;112    	{
;;;113    		if(nRet != 0)
;;;114    			return (char)nRet;
;;;115    	}
;;;116    # endif    
;;;117    #endif
;;;118    
;;;119    	if(DEBUG_PORT == 1)
;;;120    	{
;;;121    		while (1){
;;;122    			if(UART1->FSR.RX_EMPTY == 0 )
;;;123    			{
;;;124    				return (UART1->DATA);
;;;125    				
;;;126    		    }
;;;127    		}
;;;128    	}
;;;129    	else if(DEBUG_PORT == 0)
;;;130    	{
;;;131    		while (1){
;;;132    			if(UART0->FSR.RX_EMPTY == 0 )
000002  6981              LDR      r1,[r0,#0x18]
000004  0449              LSLS     r1,r1,#17
000006  d4fc              BMI      |L1.2|
;;;133    			{
;;;134    				return (UART0->DATA);
000008  6800              LDR      r0,[r0,#0]
00000a  b2c0              UXTB     r0,r0
;;;135    				
;;;136    		    }
;;;137    		}
;;;138    	}
;;;139    	else 
;;;140    	{
;;;141    		while (1){
;;;142    			if(UART2->FSR.RX_EMPTY == 0 )
;;;143    			{
;;;144    				return (UART2->DATA);
;;;145    				
;;;146    		    }
;;;147    		}
;;;148    	}
;;;149    
;;;150    }
00000c  4770              BX       lr
;;;151    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40050000

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;167    /*---------------------------------------------------------------------------------------------------------*/
;;;168    int IsDebugFifoEmpty(void)
000000  4802              LDR      r0,|L2.12|
;;;169    {
;;;170    #if(DEBUG_PORT == 0)
;;;171        return UART0->FSR.TE_FLAG;
000002  6980              LDR      r0,[r0,#0x18]
000004  00c0              LSLS     r0,r0,#3
000006  0fc0              LSRS     r0,r0,#31
;;;172    #elif(DEBUG_PORT == 1)
;;;173        return UART1->FSR.TE_FLAG;
;;;174    #else
;;;175        return UART2->FSR.TE_FLAG;
;;;176    #endif    
;;;177    }
000008  4770              BX       lr
;;;178    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40050000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;63     
;;;64     void SendChar(int ch)
000000  b500              PUSH     {lr}
;;;65     {
;;;66     #if defined(DEBUG_ENABLE_SEMIHOST)
;;;67     	g_buf[g_buf_len++] = ch;
;;;68     	g_buf[g_buf_len] = '\0';
;;;69     	if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
;;;70     	{
;;;71     
;;;72     		/* Send the char */
;;;73     		if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
;;;74             {
;;;75                 g_buf_len = 0;
;;;76     			return;
;;;77             }
;;;78             else
;;;79             {
;;;80                 int i;
;;;81     
;;;82                 for(i=0;i<g_buf_len;i++)
;;;83                     SendChar_ToUART(g_buf[i]);
;;;84     		    g_buf_len = 0;
;;;85             }
;;;86     	}
;;;87     #else
;;;88         SendChar_ToUART(ch);
000002  f7fffffe          BL       SendChar_ToUART
;;;89     #endif
;;;90     }
000006  bd00              POP      {pc}
;;;91     
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;40     
;;;41     void SendChar_ToUART(int ch)
000000  4906              LDR      r1,|L4.28|
                  |L4.2|
;;;42     {
;;;43     	if(DEBUG_PORT == 1)
;;;44     	{
;;;45     	    while(UART1->FSR.TX_FULL == 1);
;;;46     		UART1->DATA = ch;
;;;47     	    if(ch == '\n'){
;;;48     	        while(UART1->FSR.TX_FULL == 1);
;;;49     	        UART1->DATA = '\r';
;;;50     	    }
;;;51     	}
;;;52     	else if(DEBUG_PORT == 0)
;;;53     	{
;;;54     		while(UART0->FSR.TX_FULL == 1);
000002  698a              LDR      r2,[r1,#0x18]
000004  0212              LSLS     r2,r2,#8
000006  d4fc              BMI      |L4.2|
;;;55     		UART0->DATA = ch;
000008  6008              STR      r0,[r1,#0]
;;;56     	    if(ch == '\n'){
00000a  280a              CMP      r0,#0xa
00000c  d104              BNE      |L4.24|
                  |L4.14|
;;;57     	        while(UART0->FSR.TX_FULL == 1);
00000e  6988              LDR      r0,[r1,#0x18]
000010  0200              LSLS     r0,r0,#8
000012  d4fc              BMI      |L4.14|
;;;58     	        UART0->DATA = '\r';
000014  200d              MOVS     r0,#0xd
000016  6008              STR      r0,[r1,#0]
                  |L4.24|
;;;59     	    }
;;;60     	}
;;;61     }
000018  4770              BX       lr
;;;62     
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40050000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;181    /*---------------------------------------------------------------------------------------------------------*/
;;;182    void _ttywrch(int ch)
000000  b500              PUSH     {lr}
000002  f7fffffe          BL       SendChar_ToUART
;;;183    {
;;;184      SendChar(ch);
;;;185      return;
;;;186    }
000006  bd00              POP      {pc}
;;;187    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;198    
;;;199    int ferror(FILE *f) {
000000  2000              MOVS     r0,#0
;;;200      return EOF;
000002  43c0              MVNS     r0,r0
;;;201    }
000004  4770              BX       lr
;;;202    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;193    
;;;194    int fgetc(FILE *f) {
000000  b500              PUSH     {lr}
;;;195      return (GetChar());
000002  f7fffffe          BL       GetChar
;;;196    }
000006  bd00              POP      {pc}
;;;197    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;187    
;;;188    int fputc(int ch, FILE *f)
000000  b500              PUSH     {lr}
;;;189    {
000002  4603              MOV      r3,r0
000004  f7fffffe          BL       SendChar_ToUART
;;;190      SendChar(ch);
;;;191      return ch;
000008  4618              MOV      r0,r3
;;;192    }
00000a  bd00              POP      {pc}
;;;193    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;154    /*---------------------------------------------------------------------------------------------------------*/
;;;155    int kbhit(void)
000000  4802              LDR      r0,|L9.12|
;;;156    {
;;;157    #if(DEBUG_PORT == 0)
;;;158        return !UART0->FSR.RX_EMPTY;
000002  6980              LDR      r0,[r0,#0x18]
000004  0440              LSLS     r0,r0,#17
000006  17c0              ASRS     r0,r0,#31
000008  1c40              ADDS     r0,r0,#1
;;;159    #elif(DEBUG_PORT == 1)
;;;160        return !UART1->FSR.RX_EMPTY;
;;;161    #else
;;;162        return !UART2->FSR.RX_EMPTY;
;;;163    #endif    
;;;164    }
00000a  4770              BX       lr
;;;165    /*---------------------------------------------------------------------------------------------------------*/
                          ENDP

                  |L9.12|
                          DCD      0x40050000

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.13||, DATA, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.data||
                  __stdin
                          DCD      0x00000000
